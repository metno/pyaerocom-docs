

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyaerocom.colocation &mdash; pyaerocom  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> pyaerocom
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#aerocom">AeroCom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#citation">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#website-and-code-documentation">Website and code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#requirements">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#installation-of-pyaerocom">Installation of pyaerocom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#access-to-users-database">Access to users database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#getting-started">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pyaerocom-tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyaerocom</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pyaerocom.colocation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyaerocom.colocation</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Methods and / or classes to perform colocation</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="kn">import</span> <span class="n">logger</span><span class="p">,</span> <span class="n">const</span>
<span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="kn">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">pya_ver</span>
<span class="kn">from</span> <span class="nn">pyaerocom.tstype</span> <span class="kn">import</span> <span class="n">TsType</span>
<span class="kn">from</span> <span class="nn">pyaerocom.helpers</span> <span class="kn">import</span> <span class="n">isnumeric</span>
<span class="kn">from</span> <span class="nn">pyaerocom.exceptions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ColocationError</span><span class="p">,</span>
                                  <span class="n">DataUnitError</span><span class="p">,</span>
                                  <span class="n">DimensionOrderError</span><span class="p">,</span>
                                  <span class="n">MetaDataError</span><span class="p">,</span>
                                  <span class="n">TimeMatchError</span><span class="p">,</span>
                                  <span class="n">VarNotAvailableError</span><span class="p">)</span>

<span class="c1">#from pyaerocom.time_config import TS_TYPE_TO_PANDAS_FREQ</span>
<span class="kn">from</span> <span class="nn">pyaerocom.helpers</span> <span class="kn">import</span> <span class="p">(</span><span class="n">to_pandas_timestamp</span><span class="p">,</span>
                               <span class="n">to_datestring_YYYYMMDD</span><span class="p">,</span>
                               <span class="n">make_datetime_index</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyaerocom.filter</span> <span class="kn">import</span> <span class="n">Filter</span>
<span class="kn">from</span> <span class="nn">pyaerocom.colocateddata</span> <span class="kn">import</span> <span class="n">ColocatedData</span>

<span class="k">def</span> <span class="nf">_regrid_gridded</span><span class="p">(</span><span class="n">gridded</span><span class="p">,</span> <span class="n">regrid_scheme</span><span class="p">,</span> <span class="n">regrid_res_deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regrid instance of `GriddedData`</span>

<span class="sd">    Makes sure to handle different input options for `regrid_res_deg`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gridded : GriddedData</span>
<span class="sd">        instance of :class:`GriddedData` that is supposed to be regridded.</span>
<span class="sd">    regrid_scheme : str</span>
<span class="sd">        iris scheme used for regridding (defaults to area weighted regridding)</span>
<span class="sd">    regrid_res_deg : int or dict, optional</span>
<span class="sd">        regrid resolution in degrees. If specified, the input gridded data</span>
<span class="sd">        objects will be regridded in lon / lat dimension to the input</span>
<span class="sd">        resolution (if input is integer, both lat and lon are regridded to that</span>
<span class="sd">        resolution, if input is dict, use keys `lat_res_deg` and `lon_res_deg`</span>
<span class="sd">        to specify regrid resolutions, respectively).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If input for `regrid_res_deg` is invalid.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    GriddedData</span>
<span class="sd">        regridded data object</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regrid_res_deg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">regrid_res_deg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for regrid_res_deg. Need integer &#39;</span>
                             <span class="s1">&#39;or dict specifying lat and lon res&#39;</span><span class="p">)</span>
        <span class="n">regrid_res_deg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lat_res_deg</span><span class="o">=</span><span class="n">regrid_res_deg</span><span class="p">,</span>
                              <span class="n">lon_res_deg</span><span class="o">=</span><span class="n">regrid_res_deg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gridded</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="n">regrid_scheme</span><span class="p">,</span> <span class="o">**</span><span class="n">regrid_res_deg</span><span class="p">)</span>

<div class="viewcode-block" id="colocate_gridded_gridded"><a class="viewcode-back" href="../../api.html#pyaerocom.colocation.colocate_gridded_gridded">[docs]</a><span class="k">def</span> <span class="nf">colocate_gridded_gridded</span><span class="p">(</span><span class="n">gridded_data</span><span class="p">,</span> <span class="n">gridded_data_ref</span><span class="p">,</span> <span class="n">ts_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">regrid_res_deg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">vert_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">harmonise_units</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">regrid_scheme</span><span class="o">=</span><span class="s1">&#39;areaweighted&#39;</span><span class="p">,</span>
                             <span class="n">var_outlier_ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">var_ref_outlier_ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">update_baseyear_gridded</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">apply_time_resampling_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">min_num_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">colocate_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">var_keep_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">var_ref_keep_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">resample_how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Colocate 2 gridded data objects</span>

<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    - think about vertical dimension (vert_scheme input not used at the moment)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gridded_data : GriddedData</span>
<span class="sd">        gridded data (e.g. model results)</span>
<span class="sd">    gridded_data_ref : GriddedData</span>
<span class="sd">        reference dataset that is used to evaluate</span>
<span class="sd">        :attr:`gridded_data` (e.g. gridded observation data)</span>
<span class="sd">    ts_type : str</span>
<span class="sd">        desired temporal resolution of colocated data (must be valid AeroCom</span>
<span class="sd">        ts_type str such as daily, monthly, yearly..)</span>
<span class="sd">    start : :obj:`str` or :obj:`datetime64` or similar, optional</span>
<span class="sd">        start time for colocation, if None, the start time of the input</span>
<span class="sd">        :class:`GriddedData` object is used</span>
<span class="sd">    stop : :obj:`str` or :obj:`datetime64` or similar, optional</span>
<span class="sd">        stop time for colocation, if None, the stop time of the input</span>
<span class="sd">        :class:`GriddedData` object is used</span>
<span class="sd">    filter_name : str</span>
<span class="sd">        string specifying filter used (cf. :class:`pyaerocom.filter.Filter` for</span>
<span class="sd">        details). If None, then it is set to &#39;WORLD-wMOUNTAINS&#39;, which</span>
<span class="sd">        corresponds to no filtering (world with mountains).</span>
<span class="sd">        Use WORLD-noMOUNTAINS to exclude mountain sites.</span>
<span class="sd">    regrid_res_deg : int or dict, optional</span>
<span class="sd">        regrid resolution in degrees. If specified, the input gridded data</span>
<span class="sd">        objects will be regridded in lon / lat dimension to the input</span>
<span class="sd">        resolution (if input is integer, both lat and lon are regridded to that</span>
<span class="sd">        resolution, if input is dict, use keys `lat_res_deg` and `lon_res_deg`</span>
<span class="sd">        to specify regrid resolutions, respectively).</span>
<span class="sd">    remove_outliers : bool</span>
<span class="sd">        if True, outliers are removed from model and obs data before colocation,</span>
<span class="sd">        else not.</span>
<span class="sd">    vert_scheme : str</span>
<span class="sd">        string specifying scheme used to reduce the dimensionality in case</span>
<span class="sd">        input grid data contains vertical dimension. Example schemes are</span>
<span class="sd">        `mean, surface, altitude`, for details see</span>
<span class="sd">        :func:`GriddedData.to_time_series`.</span>
<span class="sd">    harmonise_units : bool</span>
<span class="sd">        if True, units are attempted to be harmonised (note: raises Exception</span>
<span class="sd">        if True and units cannot be harmonised).</span>
<span class="sd">    regrid_scheme : str</span>
<span class="sd">        iris scheme used for regridding (defaults to area weighted regridding)</span>
<span class="sd">    var_outlier_ranges : :obj:`dict`, optional</span>
<span class="sd">        dictionary specifying outlier ranges for dataset to be analysed</span>
<span class="sd">        (e.g. dict(od550aer = [-0.05, 10], ang4487aer=[0,4])). If None, then</span>
<span class="sd">        the pyaerocom default outlier ranges are used for the input variable.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    var_ref_outlier_ranges : dict, optional</span>
<span class="sd">        like `var_outlier_ranges` but for reference dataset.</span>
<span class="sd">    update_baseyear_gridded : int, optional</span>
<span class="sd">        optional input that can be set in order to redefine the time dimension</span>
<span class="sd">        in the gridded data object to be analysed. E.g., if the data object</span>
<span class="sd">        is a climatology (one year of data) that has set the base year of the</span>
<span class="sd">        time dimension to a value other than the specified input start / stop</span>
<span class="sd">        time this may be used to update the time in order to make colocation</span>
<span class="sd">        possible.</span>
<span class="sd">    apply_time_resampling_constraints : bool, optional</span>
<span class="sd">        if True, then time resampling constraints are applied as provided via</span>
<span class="sd">        :attr:`min_num_obs` or if that one is unspecified, as defined in</span>
<span class="sd">        :attr:`pyaerocom.const.OBS_MIN_NUM_RESAMPLE`. If None, than</span>
<span class="sd">        :attr:`pyaerocom.const.OBS_APPLY_TIME_RESAMPLE_CONSTRAINTS` is used</span>
<span class="sd">        (which defaults to True !!).</span>
<span class="sd">    min_num_obs : int or dict, optional</span>
<span class="sd">        minimum number of observations for resampling of time</span>
<span class="sd">    colocate_time : bool</span>
<span class="sd">        if True and if original time resolution of data is higher than desired</span>
<span class="sd">        time resolution (`ts_type`), then both datasets are colocated in time</span>
<span class="sd">        *before* resampling to lower resolution.</span>
<span class="sd">    var_keep_outliers : bool</span>
<span class="sd">        if True, then no outliers will be removed from dataset to be analysed,</span>
<span class="sd">        even if `remove_outliers` is True. That is because for model evaluation</span>
<span class="sd">        often only outliers are supposed to be removed in the observations but</span>
<span class="sd">        not in the model.</span>
<span class="sd">    var_ref_keep_outliers : bool</span>
<span class="sd">        if True, then no outliers will be removed from the reference dataset,</span>
<span class="sd">        even if `remove_outliers` is True.</span>
<span class="sd">    resample_how : str or dict</span>
<span class="sd">        string specifying how data should be aggregated when resampling in time.</span>
<span class="sd">        Default is &quot;mean&quot;. Can also be a nested dictionary, e.g.</span>
<span class="sd">        resample_how={&#39;daily&#39;: {&#39;hourly&#39; : &#39;max&#39;}} would use the maximum value</span>
<span class="sd">        to aggregate from hourly to daily, rather than the mean.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        additional keyword args (not used here, but included such that factory</span>
<span class="sd">        class can handle different methods with different inputs)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ColocatedData</span>
<span class="sd">        instance of colocated data</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vert_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This type of colocation is not implemented &#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;for gridded / gridded colocation... (</span><span class="si">{</span><span class="n">vert_scheme</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">var_outlier_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var_outlier_ranges</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">var_ref_outlier_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var_ref_outlier_ranges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">filter_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_name</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">DEFAULT_REG_FILTER</span>

    <span class="k">if</span> <span class="n">harmonise_units</span> <span class="ow">and</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">var_info</span><span class="o">.</span><span class="n">has_unit</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">convert_unit</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataUnitError</span><span class="p">(</span><span class="s1">&#39;Failed to merge data unit of reference &#39;</span>
                                    <span class="s1">&#39;gridded data object (</span><span class="si">{}</span><span class="s1">) to data unit &#39;</span>
                                    <span class="s1">&#39;of gridded data object (</span><span class="si">{}</span><span class="s1">)&#39;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                                            <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>

    <span class="n">var</span><span class="p">,</span> <span class="n">var_ref</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">var_name</span>
    <span class="k">if</span> <span class="n">remove_outliers</span><span class="p">:</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">low_ref</span><span class="p">,</span> <span class="n">high_ref</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">var_outlier_ranges</span><span class="p">:</span>
            <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">var_outlier_ranges</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">var_ref</span> <span class="ow">in</span> <span class="n">var_ref_outlier_ranges</span><span class="p">:</span>
            <span class="n">low_ref</span><span class="p">,</span> <span class="n">high_ref</span> <span class="o">=</span> <span class="n">var_ref_outlier_ranges</span><span class="p">[</span><span class="n">var_ref</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">var_keep_outliers</span><span class="p">:</span>
            <span class="n">gridded_data</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span>
                                         <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">var_ref_keep_outliers</span><span class="p">:</span>
            <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">low_ref</span><span class="p">,</span> <span class="n">high_ref</span><span class="p">,</span>
                                             <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">update_baseyear_gridded</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># update time dimension in gridded data</span>
        <span class="n">gridded_data</span><span class="o">.</span><span class="n">base_year</span> <span class="o">=</span> <span class="n">update_baseyear_gridded</span>

    <span class="k">if</span> <span class="n">regrid_res_deg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gridded_data_ref</span> <span class="o">=</span> <span class="n">_regrid_gridded</span><span class="p">(</span><span class="n">gridded_data_ref</span><span class="p">,</span>
                                           <span class="n">regrid_scheme</span><span class="p">,</span>
                                           <span class="n">regrid_res_deg</span><span class="p">)</span>
    <span class="c1"># perform regridding</span>
    <span class="k">if</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">lon_res</span> <span class="o">&lt;</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">lon_res</span><span class="p">:</span> <span class="c1">#obs has lower resolution</span>
        <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">gridded_data_ref</span><span class="p">,</span>
                                           <span class="n">scheme</span><span class="o">=</span><span class="n">regrid_scheme</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gridded_data_ref</span> <span class="o">=</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">gridded_data</span><span class="p">,</span>
                                                   <span class="n">scheme</span><span class="o">=</span><span class="n">regrid_scheme</span><span class="p">)</span>
    <span class="c1"># get start / stop of gridded data as pandas.Timestamp</span>
    <span class="n">grid_start</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
    <span class="n">grid_stop</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

    <span class="n">grid_start_ref</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
    <span class="n">grid_stop_ref</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

    <span class="c1"># time resolution of dataset to be analysed</span>
    <span class="n">grid_ts_type</span> <span class="o">=</span> <span class="n">grid_ts_type_src</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">ts_type</span>
    <span class="n">ref_ts_type</span> <span class="o">=</span> <span class="n">ref_ts_type_src</span> <span class="o">=</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">ts_type</span>
    <span class="k">if</span> <span class="n">ref_ts_type</span> <span class="o">!=</span> <span class="n">grid_ts_type</span><span class="p">:</span>
        <span class="c1"># ref data is in higher resolution</span>
        <span class="k">if</span> <span class="n">TsType</span><span class="p">(</span><span class="n">ref_ts_type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TsType</span><span class="p">(</span><span class="n">grid_ts_type</span><span class="p">):</span>

            <span class="n">gridded_data_ref</span> <span class="o">=</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span>
                    <span class="n">grid_ts_type</span><span class="p">,</span>
                    <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                    <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">)</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span>
                    <span class="n">ref_ts_type</span><span class="p">,</span>
                    <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                    <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">)</span>
            <span class="n">grid_ts_type</span> <span class="o">=</span> <span class="n">ref_ts_type</span>
    <span class="c1"># now both are in same temporal resolution</span>

    <span class="c1"># input ts_type is not specified or model is in lower resolution</span>
    <span class="c1"># than input ts_type -&gt; use model frequency to colocate</span>
    <span class="k">if</span> <span class="n">ts_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">TsType</span><span class="p">(</span><span class="n">grid_ts_type</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TsType</span><span class="p">(</span><span class="n">ts_type</span><span class="p">):</span>
        <span class="n">ts_type</span> <span class="o">=</span> <span class="n">grid_ts_type</span>

    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">grid_start</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">grid_stop</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grid_start_ref</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">grid_start_ref</span>
    <span class="k">if</span> <span class="n">grid_stop_ref</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">grid_stop_ref</span>
    <span class="c1"># check overlap</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="n">grid_start</span> <span class="ow">or</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">grid_stop</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TimeMatchError</span><span class="p">(</span><span class="s1">&#39;Input time range </span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1"> does not &#39;</span>
                             <span class="s1">&#39;overlap with data range: </span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">grid_start</span><span class="p">,</span> <span class="n">grid_stop</span><span class="p">))</span>
    <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
    <span class="n">gridded_data_ref</span> <span class="o">=</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>

    <span class="c1"># perform region extraction (if applicable)</span>
    <span class="n">regfilter</span> <span class="o">=</span> <span class="n">Filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">filter_name</span><span class="p">)</span>
    <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">regfilter</span><span class="p">(</span><span class="n">gridded_data</span><span class="p">)</span>
    <span class="n">gridded_data_ref</span> <span class="o">=</span> <span class="n">regfilter</span><span class="p">(</span><span class="n">gridded_data_ref</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ColocationError</span><span class="p">(</span><span class="s1">&#39;Shape mismatch between two colocated data &#39;</span>
                               <span class="s1">&#39;arrays, please debug&#39;</span><span class="p">)</span>
    <span class="n">files_ref</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">from_files</span><span class="p">]</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">from_files</span><span class="p">]</span>


    <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data_source&#39;</span>       <span class="p">:</span>   <span class="p">[</span><span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">data_id</span><span class="p">,</span>
                                     <span class="n">gridded_data</span><span class="o">.</span><span class="n">data_id</span><span class="p">],</span>
            <span class="s1">&#39;var_name&#39;</span>          <span class="p">:</span>   <span class="p">[</span><span class="n">var_ref</span><span class="p">,</span> <span class="n">var</span><span class="p">],</span>
            <span class="s1">&#39;ts_type&#39;</span>           <span class="p">:</span>   <span class="n">grid_ts_type</span><span class="p">,</span>
            <span class="s1">&#39;filter_name&#39;</span>       <span class="p">:</span>   <span class="n">filter_name</span><span class="p">,</span>
            <span class="s1">&#39;ts_type_src&#39;</span>       <span class="p">:</span>   <span class="p">[</span><span class="n">ref_ts_type_src</span><span class="p">,</span> <span class="n">grid_ts_type_src</span><span class="p">],</span>
            <span class="s1">&#39;start_str&#39;</span>         <span class="p">:</span>   <span class="n">to_datestring_YYYYMMDD</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
            <span class="s1">&#39;stop_str&#39;</span>          <span class="p">:</span>   <span class="n">to_datestring_YYYYMMDD</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span>
            <span class="s1">&#39;var_units&#39;</span>         <span class="p">:</span>   <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">units</span><span class="p">),</span>
                                     <span class="nb">str</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">units</span><span class="p">)],</span>
            <span class="s1">&#39;vert_scheme&#39;</span>       <span class="p">:</span>   <span class="n">vert_scheme</span><span class="p">,</span>
            <span class="s1">&#39;data_level&#39;</span>        <span class="p">:</span>   <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;revision_ref&#39;</span>      <span class="p">:</span>   <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">data_revision</span><span class="p">,</span>
            <span class="s1">&#39;from_files&#39;</span>        <span class="p">:</span>   <span class="n">files</span><span class="p">,</span>
            <span class="s1">&#39;from_files_ref&#39;</span>    <span class="p">:</span>   <span class="n">files_ref</span><span class="p">,</span>
            <span class="s1">&#39;colocate_time&#39;</span>     <span class="p">:</span>   <span class="n">colocate_time</span><span class="p">,</span>
            <span class="s1">&#39;obs_is_clim&#39;</span>       <span class="p">:</span>   <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;pyaerocom&#39;</span>         <span class="p">:</span>   <span class="n">pya_ver</span><span class="p">,</span>
            <span class="s1">&#39;apply_constraints&#39;</span> <span class="p">:</span>   <span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
            <span class="s1">&#39;min_num_obs&#39;</span>       <span class="p">:</span>   <span class="n">min_num_obs</span><span class="p">}</span>

    <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">regfilter</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">data_ref</span> <span class="o">=</span> <span class="n">gridded_data_ref</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_ref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">data_ref</span> <span class="o">=</span> <span class="n">data_ref</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">data_ref</span><span class="p">,</span>
                      <span class="n">data</span><span class="p">))</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>
    <span class="n">lons</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>


    <span class="c1"># create coordinates of DataArray</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data_source&#39;</span> <span class="p">:</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;data_source&#39;</span><span class="p">],</span>
              <span class="s1">&#39;var_name&#39;</span>    <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]),</span>
              <span class="s1">&#39;var_units&#39;</span>   <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;var_units&#39;</span><span class="p">]),</span>
              <span class="s1">&#39;ts_type_src&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;ts_type_src&#39;</span><span class="p">]),</span>
              <span class="s1">&#39;time&#39;</span>        <span class="p">:</span> <span class="n">time</span><span class="p">,</span>
              <span class="s1">&#39;latitude&#39;</span>    <span class="p">:</span> <span class="n">lats</span><span class="p">,</span>
              <span class="s1">&#39;longitude&#39;</span>   <span class="p">:</span> <span class="n">lons</span><span class="p">}</span>

    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">ColocatedData</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">arr</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

    <span class="c1"># add correct units for lat / lon dimensions</span>
    <span class="n">data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">standard_name</span>
    <span class="n">data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">standard_name</span>
    <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grid_ts_type</span> <span class="o">!=</span> <span class="n">ts_type</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="n">to_ts_type</span><span class="o">=</span><span class="n">ts_type</span><span class="p">,</span>
                                  <span class="n">colocate_time</span><span class="o">=</span><span class="n">colocate_time</span><span class="p">,</span>
                                  <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                                  <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
                                  <span class="n">how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>

<span class="k">def</span> <span class="nf">_colocate_site_data_helper</span><span class="p">(</span><span class="n">stat_data</span><span class="p">,</span> <span class="n">stat_data_ref</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">var_ref</span><span class="p">,</span>
                               <span class="n">ts_type</span><span class="p">,</span> <span class="n">resample_how</span><span class="p">,</span>
                               <span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                               <span class="n">min_num_obs</span><span class="p">,</span>
                               <span class="n">use_climatology_ref</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper method that colocates two timeseries from 2 StationData objects</span>

<span class="sd">    Used in main loop of :func:`colocate_gridded_ungridded`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stat_data : StationData</span>
<span class="sd">        first data object (usually the one that is to be compared with obs)</span>
<span class="sd">    stat_data_ref : StationData</span>
<span class="sd">        second data object (usually obs)</span>
<span class="sd">    var : str</span>
<span class="sd">        variable to be used from `stat_data`</span>
<span class="sd">    var_ref : str</span>
<span class="sd">        variable to be used from `stat_data_ref`</span>
<span class="sd">    ts_type : str</span>
<span class="sd">        output frequency</span>
<span class="sd">    resample_how : str or dict</span>
<span class="sd">        string specifying how data should be aggregated when resampling in time.</span>
<span class="sd">        Default is &quot;mean&quot;. Can also be a nested dictionary, e.g.</span>
<span class="sd">        resample_how={&#39;daily&#39;: {&#39;hourly&#39; : &#39;max&#39;}} would use the maximum value</span>
<span class="sd">        to aggregate from hourly to daily, rather than the mean.</span>
<span class="sd">    apply_time_resampling_constraints : bool, optional</span>
<span class="sd">        if True, then time resampling constraints are applied as provided via</span>
<span class="sd">        :attr:`min_num_obs` or if that one is unspecified, as defined in</span>
<span class="sd">        :attr:`pyaerocom.const.OBS_MIN_NUM_RESAMPLE`. If None, than</span>
<span class="sd">        :attr:`pyaerocom.const.OBS_APPLY_TIME_RESAMPLE_CONSTRAINTS` is used</span>
<span class="sd">        (which defaults to True !!).</span>
<span class="sd">    min_num_obs : int or dict, optional</span>
<span class="sd">        minimum number of observations for resampling of time</span>
<span class="sd">    use_climatology_ref : bool</span>
<span class="sd">        if True, climatological timeseries are used from observations</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        dataframe containing the colocated input data (column names are</span>
<span class="sd">        data and ref)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get grid and obs timeseries data (that may be sampled in arbitrary</span>
    <span class="c1"># time resolution, particularly the obs data)</span>
    <span class="n">grid_ts2</span> <span class="o">=</span> <span class="n">stat_data</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span>
                <span class="n">var</span><span class="p">,</span>
                <span class="n">ts_type</span><span class="o">=</span><span class="n">ts_type</span><span class="p">,</span>
                <span class="n">how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">,</span>
                <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
                <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">var</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">use_climatology_ref</span><span class="p">:</span>
        <span class="n">obs_ts2</span> <span class="o">=</span> <span class="n">stat_data_ref</span><span class="o">.</span><span class="n">calc_climatology</span><span class="p">(</span>
                <span class="n">var_ref</span><span class="p">,</span>
                <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">)[</span><span class="n">var_ref</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obs_ts2</span> <span class="o">=</span> <span class="n">stat_data_ref</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span>
                    <span class="n">var_ref</span><span class="p">,</span>
                    <span class="n">ts_type</span><span class="o">=</span><span class="n">ts_type</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">,</span>
                    <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                    <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
                    <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">var_ref</span><span class="p">]</span>

    <span class="c1"># fill up missing time stamps</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">obs_ts2</span><span class="p">,</span> <span class="n">grid_ts2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="colocate_gridded_ungridded"><a class="viewcode-back" href="../../api.html#pyaerocom.colocation.colocate_gridded_ungridded">[docs]</a><span class="k">def</span> <span class="nf">colocate_gridded_ungridded</span><span class="p">(</span><span class="n">gridded_data</span><span class="p">,</span> <span class="n">ungridded_data</span><span class="p">,</span> <span class="n">ts_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">regrid_res_deg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">vert_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">harmonise_units</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">regrid_scheme</span><span class="o">=</span><span class="s1">&#39;areaweighted&#39;</span><span class="p">,</span>
                               <span class="n">var_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">var_outlier_ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">var_ref_outlier_ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">update_baseyear_gridded</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">ignore_station_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">apply_time_resampling_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">min_num_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">colocate_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">var_keep_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">var_ref_keep_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">use_climatology_ref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">resample_how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Colocate gridded with ungridded data (low level method)</span>

<span class="sd">    For high-level colocation see :class:`pyaerocom.colocation_auto.Colocator`</span>
<span class="sd">    and :class:`pyaerocom.colocation_auto.ColocationSetup`</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Uses the variable that is contained in input :class:`GriddedData` object</span>
<span class="sd">    (since these objects only contain a single variable). If this variable</span>
<span class="sd">    is not contained in observation data (or contained but using a different</span>
<span class="sd">    variable name) you may specify the obs variable to be used via input arg</span>
<span class="sd">    `var_ref`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gridded_data : GriddedData</span>
<span class="sd">        gridded data object (e.g. model results).</span>
<span class="sd">    ungridded_data : UngriddedData</span>
<span class="sd">        ungridded data object (e.g. observations).</span>
<span class="sd">    ts_type : str</span>
<span class="sd">        desired temporal resolution of colocated data (must be valid AeroCom</span>
<span class="sd">        ts_type str such as daily, monthly, yearly.).</span>
<span class="sd">    start : :obj:`str` or :obj:`datetime64` or similar, optional</span>
<span class="sd">        start time for colocation, if None, the start time of the input</span>
<span class="sd">        :class:`GriddedData` object is used.</span>
<span class="sd">    stop : :obj:`str` or :obj:`datetime64` or similar, optional</span>
<span class="sd">        stop time for colocation, if None, the stop time of the input</span>
<span class="sd">        :class:`GriddedData` object is used</span>
<span class="sd">    filter_name : str</span>
<span class="sd">        string specifying filter used (cf. :class:`pyaerocom.filter.Filter` for</span>
<span class="sd">        details). If None, then it is set to &#39;WORLD-wMOUNTAINS&#39;, which</span>
<span class="sd">        corresponds to no filtering (world with mountains).</span>
<span class="sd">        Use WORLD-noMOUNTAINS to exclude mountain sites.</span>
<span class="sd">    regrid_res_deg : int or dict, optional</span>
<span class="sd">        regrid resolution in degrees. If specified, the input gridded data</span>
<span class="sd">        object will be regridded in lon / lat dimension to the input</span>
<span class="sd">        resolution (if input is integer, both lat and lon are regridded to that</span>
<span class="sd">        resolution, if input is dict, use keys `lat_res_deg` and `lon_res_deg`</span>
<span class="sd">        to specify regrid resolutions, respectively).</span>
<span class="sd">    remove_outliers : bool</span>
<span class="sd">        if True, outliers are removed from model and obs data before colocation,</span>
<span class="sd">        else not. Outlier ranges can be specified via input args</span>
<span class="sd">        `var_outlier_ranges` and `var_ref_outlier_ranges`.</span>
<span class="sd">    vert_scheme : str</span>
<span class="sd">        string specifying scheme used to reduce the dimensionality in case</span>
<span class="sd">        input grid data contains vertical dimension. Example schemes are</span>
<span class="sd">        `mean, surface, altitude`, for details see</span>
<span class="sd">        :func:`GriddedData.to_time_series`.</span>
<span class="sd">    harmonise_units : bool</span>
<span class="sd">        if True, units are attempted to be harmonised (note: raises Exception</span>
<span class="sd">        if True and units cannot be harmonised).</span>
<span class="sd">    var_ref : :obj:`str`, optional</span>
<span class="sd">        variable against which data in :attr:`gridded_data` is supposed to be</span>
<span class="sd">        compared. If None, then the same variable is used</span>
<span class="sd">        (i.e. `gridded_data.var_name`).</span>
<span class="sd">    var_outlier_ranges : dict, optional</span>
<span class="sd">        dictionary specifying outlier ranges for dataset to be analysed</span>
<span class="sd">        (e.g. dict(od550aer = [-0.05, 10], ang4487aer=[0,4])). If None, then</span>
<span class="sd">        the pyaerocom default outlier ranges are used for the input variable.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    var_ref_outlier_ranges : dict, optional</span>
<span class="sd">        like `var_outlier_ranges` but for reference dataset.</span>
<span class="sd">    update_baseyear_gridded : int, optional</span>
<span class="sd">        optional input that can be set in order to re-define the time dimension</span>
<span class="sd">        in the gridded data object to be analysed. E.g., if the data object</span>
<span class="sd">        is a climatology (one year of data) that has set the base year of the</span>
<span class="sd">        time dimension to a value other than the specified input start / stop</span>
<span class="sd">        time this may be used to update the time in order to make colocation</span>
<span class="sd">        possible.</span>
<span class="sd">    ignore_station_names : str or list, optional</span>
<span class="sd">        station name or pattern or list of station names or patterns that should</span>
<span class="sd">        be ignored</span>
<span class="sd">    apply_time_resampling_constraints : bool, optional</span>
<span class="sd">        if True, then time resampling constraints are applied as provided via</span>
<span class="sd">        :attr:`min_num_obs` or if that one is unspecified, as defined in</span>
<span class="sd">        :attr:`pyaerocom.const.OBS_MIN_NUM_RESAMPLE`. If None, than</span>
<span class="sd">        :attr:`pyaerocom.const.OBS_APPLY_TIME_RESAMPLE_CONSTRAINTS` is used</span>
<span class="sd">        (which defaults to True !!).</span>
<span class="sd">    min_num_obs : int or dict, optional</span>
<span class="sd">        minimum number of observations for resampling of time</span>
<span class="sd">    colocate_time : bool</span>
<span class="sd">        if True and if original time resolution of data is higher than desired</span>
<span class="sd">        time resolution (`ts_type`), then both datasets are colocated in time</span>
<span class="sd">        *before* resampling to lower resolution.</span>
<span class="sd">    var_keep_outliers : bool</span>
<span class="sd">        if True, then no outliers will be removed from dataset to be analysed,</span>
<span class="sd">        even if `remove_outliers` is True. That is because for model evaluation</span>
<span class="sd">        often only outliers are supposed to be removed in the observations but</span>
<span class="sd">        not in the model.</span>
<span class="sd">    var_ref_keep_outliers : bool</span>
<span class="sd">        if True, then no outliers will be removed from the reference dataset,</span>
<span class="sd">        even if `remove_outliers` is True.</span>
<span class="sd">    use_climatology_ref : bool</span>
<span class="sd">        if True, climatological timeseries are used from observations</span>
<span class="sd">    resample_how : str or dict</span>
<span class="sd">        string specifying how data should be aggregated when resampling in time.</span>
<span class="sd">        Default is &quot;mean&quot;. Can also be a nested dictionary, e.g.</span>
<span class="sd">        resample_how={&#39;daily&#39;: {&#39;hourly&#39; : &#39;max&#39;}} would use the maximum value</span>
<span class="sd">        to aggregate from hourly to daily, rather than the mean.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        additional keyword args (passed to</span>
<span class="sd">        :func:`UngriddedData.to_station_data_all`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ColocatedData</span>
<span class="sd">        instance of colocated data</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    VarNotAvailableError</span>
<span class="sd">        if grid data variable is not available in ungridded data object</span>
<span class="sd">    AttributeError</span>
<span class="sd">        if instance of input :class:`UngriddedData` object contains more than</span>
<span class="sd">        one dataset</span>
<span class="sd">    TimeMatchError</span>
<span class="sd">        if gridded data time range does not overlap with input time range</span>
<span class="sd">    ColocationError</span>
<span class="sd">        if none of the data points in input :class:`UngriddedData` matches</span>
<span class="sd">        the input colocation constraints</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">var_outlier_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var_outlier_ranges</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">var_ref_outlier_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var_ref_outlier_ranges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">filter_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_name</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">DEFAULT_REG_FILTER</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">gridded_data</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
        <span class="n">gridded_data</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>

    <span class="n">var</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">var_name</span>
    <span class="n">aerocom_var</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">var_name_aerocom</span>
    <span class="k">if</span> <span class="n">var_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">aerocom_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var_ref</span> <span class="o">=</span> <span class="n">aerocom_var</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_ref</span> <span class="o">=</span> <span class="n">var</span>

    <span class="k">if</span> <span class="n">remove_outliers</span><span class="p">:</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">low_ref</span><span class="p">,</span> <span class="n">high_ref</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">var_outlier_ranges</span><span class="p">:</span>
            <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">var_outlier_ranges</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">var_ref</span> <span class="ow">in</span> <span class="n">var_ref_outlier_ranges</span><span class="p">:</span>
            <span class="n">low_ref</span><span class="p">,</span> <span class="n">high_ref</span> <span class="o">=</span> <span class="n">var_ref_outlier_ranges</span><span class="p">[</span><span class="n">var_ref</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">var_ref</span> <span class="ow">in</span> <span class="n">ungridded_data</span><span class="o">.</span><span class="n">contains_vars</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VarNotAvailableError</span><span class="p">(</span><span class="s1">&#39;Variable </span><span class="si">{}</span><span class="s1"> is not available in ungridded &#39;</span>
                                   <span class="s1">&#39;data (which contains </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_ref</span><span class="p">,</span>
                                           <span class="n">ungridded_data</span><span class="o">.</span><span class="n">contains_vars</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ungridded_data</span><span class="o">.</span><span class="n">contains_datasets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Colocation can only be performed with &#39;</span>
                             <span class="s1">&#39;ungridded data objects that only contain a &#39;</span>
                             <span class="s1">&#39;single dataset. Use method `extract_dataset` of &#39;</span>
                             <span class="s1">&#39;UngriddedData object to extract single datasets&#39;</span><span class="p">)</span>

    <span class="n">dataset_ref</span> <span class="o">=</span> <span class="n">ungridded_data</span><span class="o">.</span><span class="n">contains_datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">update_baseyear_gridded</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># update time dimension in gridded data</span>
        <span class="n">gridded_data</span><span class="o">.</span><span class="n">base_year</span> <span class="o">=</span> <span class="n">update_baseyear_gridded</span>

    <span class="n">grid_ts_type_src</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">ts_type</span>
    <span class="n">grid_ts_type</span> <span class="o">=</span> <span class="n">TsType</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">ts_type</span> <span class="o">=</span> <span class="n">TsType</span><span class="p">(</span><span class="n">ts_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ts_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">grid_ts_type</span> <span class="o">&lt;</span> <span class="n">ts_type</span><span class="p">:</span>
        <span class="n">ts_type</span> <span class="o">=</span> <span class="n">grid_ts_type</span>
    <span class="k">elif</span> <span class="n">grid_ts_type</span> <span class="o">&gt;</span> <span class="n">ts_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">colocate_time</span><span class="p">:</span>
        <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ts_type</span><span class="p">),</span>
                                                  <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                                                  <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
                                                  <span class="n">how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">)</span>
        <span class="n">grid_ts_type</span> <span class="o">=</span> <span class="n">ts_type</span>

    <span class="c1"># get start / stop of gridded data as pandas.Timestamp</span>
    <span class="n">grid_start</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
    <span class="n">grid_stop</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">grid_start</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">grid_stop</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">grid_start</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">grid_start</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">grid_stop</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">grid_stop</span>
    <span class="c1"># check overlap</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="n">grid_start</span> <span class="ow">or</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">grid_stop</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TimeMatchError</span><span class="p">(</span><span class="s1">&#39;Input time range </span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1"> does not &#39;</span>
                             <span class="s1">&#39;overlap with data range: </span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">grid_start</span><span class="p">,</span> <span class="n">grid_stop</span><span class="p">))</span>
    <span class="c1"># create instance of Filter class (may, in the future, also include all</span>
    <span class="c1"># filter options, e.g. start, stop, variables, only land, only oceans, and</span>
    <span class="c1"># may also be linked with other data object, e.g. if data is only supposed</span>
    <span class="c1"># to be used if other data object exceeds a certain threshold... but for</span>
    <span class="c1"># now, only region and altitude range)</span>
    <span class="n">regfilter</span> <span class="o">=</span> <span class="n">Filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">filter_name</span><span class="p">)</span>

    <span class="c1"># apply filter to data</span>
    <span class="n">ungridded_data</span> <span class="o">=</span> <span class="n">regfilter</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ungridded_data</span><span class="p">)</span>

    <span class="c1">#crop time</span>
    <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">regfilter</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">gridded_data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">grid_start</span> <span class="ow">or</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="n">grid_stop</span><span class="p">:</span>
        <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">regrid_res_deg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gridded_data</span> <span class="o">=</span> <span class="n">_regrid_gridded</span><span class="p">(</span><span class="n">gridded_data</span><span class="p">,</span> <span class="n">regrid_scheme</span><span class="p">,</span>
                                       <span class="n">regrid_res_deg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">var_ref_keep_outliers</span><span class="p">:</span> <span class="c1">#called twice if used via Colocator, this should go out here</span>
        <span class="n">ungridded_data</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">var_ref</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">low</span><span class="o">=</span><span class="n">low_ref</span><span class="p">,</span>
                                       <span class="n">high</span><span class="o">=</span><span class="n">high_ref</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_climatology_ref</span><span class="p">:</span>
        <span class="n">col_freq</span><span class="o">=</span><span class="s1">&#39;monthly&#39;</span>
        <span class="n">obs_start</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CLIM_START</span>
        <span class="n">obs_stop</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CLIM_STOP</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">col_freq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">grid_ts_type</span><span class="p">)</span><span class="c1">#TS_TYPE_TO_PANDAS_FREQ[grid_ts_type]</span>
        <span class="n">obs_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">obs_stop</span> <span class="o">=</span> <span class="n">stop</span>


    <span class="n">latitude</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>
    <span class="n">longitude</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
    <span class="n">lat_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">latitude</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">latitude</span><span class="p">)]</span>
    <span class="n">lon_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">longitude</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">longitude</span><span class="p">)]</span>
    <span class="n">ungridded_data</span> <span class="o">=</span> <span class="n">ungridded_data</span><span class="o">.</span><span class="n">filter_by_meta</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lat_range</span><span class="p">,</span>
                                                   <span class="n">longitude</span><span class="o">=</span><span class="n">lon_range</span><span class="p">)</span>

    <span class="c1"># get timeseries from all stations in provided time resolution</span>
    <span class="c1"># (time resampling is done below in main loop)</span>
    <span class="n">all_stats</span> <span class="o">=</span> <span class="n">ungridded_data</span><span class="o">.</span><span class="n">to_station_data_all</span><span class="p">(</span>
            <span class="n">vars_to_convert</span><span class="o">=</span><span class="n">var_ref</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">obs_start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">obs_stop</span><span class="p">,</span>
            <span class="n">by_station_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_station_names</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

    <span class="n">obs_stat_data</span> <span class="o">=</span> <span class="n">all_stats</span><span class="p">[</span><span class="s1">&#39;stats&#39;</span><span class="p">]</span>
    <span class="n">ungridded_lons</span> <span class="o">=</span> <span class="n">all_stats</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span>
    <span class="n">ungridded_lats</span> <span class="o">=</span> <span class="n">all_stats</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_stat_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VarNotAvailableError</span><span class="p">(</span><span class="s1">&#39;Variable </span><span class="si">{}</span><span class="s1"> is not available in specified &#39;</span>
                                   <span class="s1">&#39;time interval (</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">)&#39;</span>
                                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_ref</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
    <span class="c1"># make sure the gridded data is in the right dimension</span>
    <span class="k">if</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">vert_scheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vert_scheme</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vert_scheme</span> <span class="ow">in</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">SUPPORTED_VERT_SCHEMES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Vertical scheme </span><span class="si">{}</span><span class="s1"> is not supported&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vert_scheme</span><span class="p">))</span>

    <span class="n">grid_stat_data</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">to_time_series</span><span class="p">(</span><span class="n">longitude</span><span class="o">=</span><span class="n">ungridded_lons</span><span class="p">,</span>
                                                 <span class="n">latitude</span><span class="o">=</span><span class="n">ungridded_lats</span><span class="p">,</span>
                                                 <span class="n">vert_scheme</span><span class="o">=</span><span class="n">vert_scheme</span><span class="p">)</span>

    <span class="n">pd_freq</span> <span class="o">=</span> <span class="n">TsType</span><span class="p">(</span><span class="n">col_freq</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas_freq</span><span class="p">()</span>
    <span class="n">time_idx</span> <span class="o">=</span> <span class="n">make_datetime_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">pd_freq</span><span class="p">)</span>

    <span class="n">coldata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_idx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_stat_data</span><span class="p">)))</span>

    <span class="n">lons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">alts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">station_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">ungridded_unit</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ts_type_src_ref</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">harmonise_units</span><span class="p">:</span>
        <span class="n">gridded_unit</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gridded_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># loop over all stations and append to colocated data object</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obs_stat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obs_stat_data</span><span class="p">):</span>
        <span class="c1"># ToDo: consider removing to keep ts_type_src_ref (this was probably</span>
        <span class="c1"># introduced for EBAS were the original data frequency is not constant</span>
        <span class="c1"># but can vary from site to site)</span>
        <span class="k">if</span> <span class="n">ts_type_src_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ts_type_src_ref</span> <span class="o">=</span> <span class="n">obs_stat</span><span class="p">[</span><span class="s1">&#39;ts_type_src&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">obs_stat</span><span class="p">[</span><span class="s1">&#39;ts_type_src&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ts_type_src_ref</span><span class="p">:</span>
            <span class="n">spl</span> <span class="o">=</span> <span class="n">ts_type_src_ref</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obs_stat</span><span class="p">[</span><span class="s1">&#39;ts_type_src&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">spl</span><span class="p">:</span>
                <span class="n">spl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_stat</span><span class="p">[</span><span class="s1">&#39;ts_type_src&#39;</span><span class="p">])</span>
            <span class="n">ts_type_src_ref</span> <span class="o">=</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ungridded_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ungridded_unit</span> <span class="o">=</span> <span class="n">obs_stat</span><span class="p">[</span><span class="s1">&#39;var_info&#39;</span><span class="p">][</span><span class="n">var_ref</span><span class="p">][</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="c1">#variable information or unit is not defined</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">obs_stat</span><span class="p">[</span><span class="s1">&#39;var_info&#39;</span><span class="p">][</span><span class="n">var_ref</span><span class="p">][</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unit</span> <span class="o">==</span> <span class="n">ungridded_unit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot perform colocation. Ungridded data &#39;</span>
                             <span class="s1">&#39;object contains different units (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_ref</span><span class="p">))</span>
        <span class="c1"># get observations (Note: the index of the observation time series</span>
        <span class="c1"># is already in the specified frequency format, and thus, does not</span>
        <span class="c1"># need to be updated, for details (or if errors occur), cf.</span>
        <span class="c1"># UngriddedData.to_station_data, where the conversion happens)</span>

        <span class="c1"># get model station data</span>
        <span class="n">grid_stat</span> <span class="o">=</span> <span class="n">grid_stat_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">harmonise_units</span><span class="p">:</span>
            <span class="n">grid_unit</span> <span class="o">=</span> <span class="n">grid_stat</span><span class="o">.</span><span class="n">get_unit</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">obs_unit</span> <span class="o">=</span> <span class="n">obs_stat</span><span class="o">.</span><span class="n">get_unit</span><span class="p">(</span><span class="n">var_ref</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grid_unit</span> <span class="o">==</span> <span class="n">obs_unit</span><span class="p">:</span>
                <span class="n">grid_stat</span><span class="o">.</span><span class="n">convert_unit</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">obs_unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gridded_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gridded_unit</span> <span class="o">=</span> <span class="n">obs_unit</span>

        <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">var_keep_outliers</span><span class="p">:</span>
            <span class="c1"># don&#39;t check if harmonise_units is active, because the</span>
            <span class="c1"># remove_outliers method checks units based on AeroCom default</span>
            <span class="c1"># variables, and a variable mapping might be active, i.e.</span>
            <span class="c1"># sometimes models use abs550aer for absorption coefficients</span>
            <span class="c1"># with units [m-1] and not for AAOD (which is the AeroCom default</span>
            <span class="c1"># and unitless. Hence, unit check in remove_outliers works only</span>
            <span class="c1"># if the variable name (and unit) corresonds to AeroCom default)</span>
            <span class="c1">#chk_unit = not harmonise_units</span>
            <span class="n">grid_stat</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">,</span>
                                      <span class="n">check_unit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">_df</span> <span class="o">=</span> <span class="n">_colocate_site_data_helper</span><span class="p">(</span>

            <span class="n">stat_data</span><span class="o">=</span><span class="n">grid_stat</span><span class="p">,</span>
            <span class="n">stat_data_ref</span><span class="o">=</span><span class="n">obs_stat</span><span class="p">,</span>
            <span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">var_ref</span><span class="o">=</span><span class="n">var_ref</span><span class="p">,</span>
            <span class="n">ts_type</span><span class="o">=</span><span class="n">col_freq</span><span class="p">,</span>
            <span class="n">resample_how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">,</span>
            <span class="n">apply_time_resampling_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
            <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
            <span class="n">use_climatology_ref</span><span class="o">=</span><span class="n">use_climatology_ref</span><span class="p">)</span>

        <span class="c1"># assign the unified timeseries data to the colocated data array</span>
        <span class="n">coldata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_df</span><span class="p">[</span><span class="s1">&#39;ref&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">coldata</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_df</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">lons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_stat</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
        <span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_stat</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
        <span class="n">alts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_stat</span><span class="o">.</span><span class="n">altitude</span><span class="p">)</span>
        <span class="n">station_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_stat</span><span class="o">.</span><span class="n">station_name</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">revision</span> <span class="o">=</span> <span class="n">ungridded_data</span><span class="o">.</span><span class="n">data_revision</span><span class="p">[</span><span class="n">dataset_ref</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">revision</span> <span class="o">=</span> <span class="n">ungridded_data</span><span class="o">.</span><span class="n">_get_data_revision_helper</span><span class="p">(</span><span class="n">dataset_ref</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MetaDataError</span><span class="p">:</span>
            <span class="n">revision</span> <span class="o">=</span> <span class="s1">&#39;MULTIPLE&#39;</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">revision</span> <span class="o">=</span> <span class="s1">&#39;n/a&#39;</span>

    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">from_files</span><span class="p">]</span>

    <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data_source&#39;</span>       <span class="p">:</span>   <span class="p">[</span><span class="n">dataset_ref</span><span class="p">,</span>
                                     <span class="n">gridded_data</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
            <span class="s1">&#39;var_name&#39;</span>          <span class="p">:</span>   <span class="p">[</span><span class="n">var_ref</span><span class="p">,</span> <span class="n">var</span><span class="p">],</span>
            <span class="s1">&#39;ts_type&#39;</span>           <span class="p">:</span>   <span class="n">col_freq</span><span class="p">,</span> <span class="c1"># will be updated below if resampling</span>
            <span class="s1">&#39;filter_name&#39;</span>       <span class="p">:</span>   <span class="n">filter_name</span><span class="p">,</span>
            <span class="s1">&#39;ts_type_src&#39;</span>       <span class="p">:</span>   <span class="p">[</span><span class="n">ts_type_src_ref</span><span class="p">,</span> <span class="n">grid_ts_type_src</span><span class="p">],</span>
            <span class="s1">&#39;start_str&#39;</span>         <span class="p">:</span>   <span class="n">to_datestring_YYYYMMDD</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
            <span class="s1">&#39;stop_str&#39;</span>          <span class="p">:</span>   <span class="n">to_datestring_YYYYMMDD</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span>
            <span class="s1">&#39;var_units&#39;</span>         <span class="p">:</span>   <span class="p">[</span><span class="n">ungridded_unit</span><span class="p">,</span>
                                     <span class="n">gridded_unit</span><span class="p">],</span>
            <span class="s1">&#39;vert_scheme&#39;</span>       <span class="p">:</span>   <span class="n">vert_scheme</span><span class="p">,</span>
            <span class="s1">&#39;data_level&#39;</span>        <span class="p">:</span>   <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;revision_ref&#39;</span>      <span class="p">:</span>   <span class="n">revision</span><span class="p">,</span>
            <span class="s1">&#39;from_files&#39;</span>        <span class="p">:</span>   <span class="n">files</span><span class="p">,</span>
            <span class="s1">&#39;from_files_ref&#39;</span>    <span class="p">:</span>   <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;stations_ignored&#39;</span>  <span class="p">:</span>   <span class="n">ignore_station_names</span><span class="p">,</span>
            <span class="s1">&#39;colocate_time&#39;</span>     <span class="p">:</span>   <span class="n">colocate_time</span><span class="p">,</span>
            <span class="s1">&#39;obs_is_clim&#39;</span>       <span class="p">:</span>   <span class="n">use_climatology_ref</span><span class="p">,</span>
            <span class="s1">&#39;pyaerocom&#39;</span>         <span class="p">:</span>   <span class="n">pya_ver</span><span class="p">,</span>
            <span class="s1">&#39;apply_constraints&#39;</span> <span class="p">:</span>   <span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
            <span class="s1">&#39;min_num_obs&#39;</span>       <span class="p">:</span>   <span class="n">min_num_obs</span><span class="p">,</span>
            <span class="s1">&#39;outliers_removed&#39;</span>  <span class="p">:</span>   <span class="n">remove_outliers</span><span class="p">}</span>


    <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">regfilter</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="c1"># create coordinates of DataArray</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data_source&#39;</span> <span class="p">:</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;data_source&#39;</span><span class="p">],</span>
              <span class="s1">&#39;var_name&#39;</span>    <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]),</span>
              <span class="s1">&#39;var_units&#39;</span>   <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;var_units&#39;</span><span class="p">]),</span>
              <span class="s1">&#39;ts_type_src&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;ts_type_src&#39;</span><span class="p">]),</span>
              <span class="s1">&#39;time&#39;</span>        <span class="p">:</span> <span class="n">time_idx</span><span class="p">,</span>
              <span class="s1">&#39;station_name&#39;</span><span class="p">:</span> <span class="n">station_names</span><span class="p">,</span>
              <span class="s1">&#39;latitude&#39;</span>    <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">lats</span><span class="p">),</span>
              <span class="s1">&#39;longitude&#39;</span>   <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">lons</span><span class="p">),</span>
              <span class="s1">&#39;altitude&#39;</span>    <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">alts</span><span class="p">)</span>
              <span class="p">}</span>

    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data_source&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;station_name&#39;</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">ColocatedData</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">coldata</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">var</span><span class="p">,</span>
                         <span class="n">attrs</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

    <span class="c1"># add correct units for lat / lon dimensions</span>
    <span class="n">data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">standard_name</span>
    <span class="n">data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridded_data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">standard_name</span>
    <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gridded_data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">col_freq</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts_type</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="n">to_ts_type</span><span class="o">=</span><span class="n">ts_type</span><span class="p">,</span>
                                  <span class="n">colocate_time</span><span class="o">=</span><span class="n">colocate_time</span><span class="p">,</span>
                                  <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_time_resampling_constraints</span><span class="p">,</span>
                                  <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">,</span>
                                  <span class="n">how</span><span class="o">=</span><span class="n">resample_how</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="correct_model_stp_coldata"><a class="viewcode-back" href="../../api.html#pyaerocom.colocation.correct_model_stp_coldata">[docs]</a><span class="k">def</span> <span class="nf">correct_model_stp_coldata</span><span class="p">(</span><span class="n">coldata</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">273.15</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Correct modeldata in colocated data object to STP conditions</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    BETA version, quite unelegant coded (at 8pm 3 weeks before IPCC deadline),</span>
<span class="sd">    but should do the job for 2010 monthly colocated data files (AND NOTHING</span>
<span class="sd">    ELSE)!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">coldata</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Can only handle 3D coldata so far...&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">coldata</span><span class="o">.</span><span class="n">ts_type</span> <span class="o">==</span> <span class="s1">&#39;monthly&#39;</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coldata</span><span class="o">.</span><span class="n">time</span><span class="p">)</span><span class="o">==</span><span class="mi">12</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Can only handle monthly colocated data files &#39;</span>
                                  <span class="s1">&#39;so far (since ERA5 temps are only available) &#39;</span>
                                  <span class="s1">&#39;in monthly resolution&#39;</span><span class="p">)</span>
    <span class="n">startyr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">coldata</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
    <span class="n">stopyr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">coldata</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">==</span><span class="mi">2010</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">startyr</span><span class="p">,</span> <span class="n">stopyr</span><span class="p">)]):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Can only handle 2010 monthly data so far&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">coldata</span> <span class="o">=</span> <span class="n">coldata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">ERA5_SURFTEMP_FILE</span><span class="p">)[</span><span class="s1">&#39;t2m&#39;</span><span class="p">]</span>
    <span class="kn">from</span> <span class="nn">geonum.atmosphere</span> <span class="kn">import</span> <span class="n">pressure</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">coldata</span><span class="o">.</span><span class="n">data</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                 <span class="n">arr</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">station_name</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">pressure</span><span class="p">()</span> <span class="c1">#STD conditions sea level</span>
    <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Correcting model data in ColocatedData instance to STP&#39;</span><span class="p">)</span>
    <span class="n">cfacs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meantemps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mintemps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">maxtemps</span> <span class="o">=</span><span class="p">[]</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;, Lat&#39;</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;, Lon&#39;</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pressure</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span>
        <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span> <span class="n">alt</span><span class="p">)</span>
        <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;P=&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;hPa&#39;</span><span class="p">)</span>

        <span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span>

        <span class="n">temps</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">longitude</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>

        <span class="n">meantemps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temps</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">mintemps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temps</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">maxtemps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temps</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">temps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Check timestamps&#39;</span><span class="p">)</span>
        <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Mean Temp: &#39;</span><span class="p">,</span> <span class="n">temps</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span> <span class="s1">&#39; C&#39;</span><span class="p">)</span>

        <span class="n">corrfacs</span> <span class="o">=</span> <span class="p">(</span><span class="n">p0</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">temps</span> <span class="o">/</span> <span class="n">t0</span><span class="p">)</span>

        <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Corr fac:&#39;</span><span class="p">,</span> <span class="n">corrfacs</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="s1">&#39;+/-&#39;</span><span class="p">,</span> <span class="n">corrfacs</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>

        <span class="n">cfacs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corrfacs</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

        <span class="c1">#mularr = xr.DataArray(corrfacs)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">station_name</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
    <span class="c1"># =============================================================================</span>
    <span class="c1">#     const.logger.info(corrfacs)</span>
    <span class="c1">#     const.logger.info(&#39;Before&#39;, arr[1, :, i].data)</span>
    <span class="c1">#     corrfacs[0] = 1</span>
    <span class="c1"># =============================================================================</span>
        <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">corrfacs</span>
        <span class="c1">#const.logger.info(&#39;After&#39;, arr[1, :, i].data)</span>
    <span class="n">cfacs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cfacs</span><span class="p">)</span>

    <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Min: &#39;</span><span class="p">,</span> <span class="n">cfacs</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Mean: &#39;</span><span class="p">,</span> <span class="n">cfacs</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
    <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Max: &#39;</span><span class="p">,</span> <span class="n">cfacs</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Model_STP_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">newcoords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">pres</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">ps</span><span class="p">),</span>
                     <span class="n">temp_mean</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">meantemps</span><span class="p">),</span>
                     <span class="n">temp_min</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">mintemps</span><span class="p">),</span>
                     <span class="n">temp_max</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">maxtemps</span><span class="p">),</span>
                     <span class="n">stp_corrfac_mean</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;station_name&#39;</span><span class="p">,</span> <span class="n">cfacs</span><span class="p">))</span>

    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">newcoords</span><span class="p">)</span>

    <span class="n">info_str</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Correction factors to convert model data from ambient to &#39;</span>
                <span class="s1">&#39;STP were computed using corrfac=(p0/p)*(T/T0) with T0=273K &#39;</span>
                <span class="s1">&#39;and p0=1013 hPa and p is the pressure at the station location &#39;</span>
                <span class="s1">&#39;(which was computed assuming a standard atmosphere and using &#39;</span>
                <span class="s1">&#39;the station altitude) and T is the 2m surface temperature at &#39;</span>
                <span class="s1">&#39;the station, applied on a monthly basis and estimated using &#39;</span>
                <span class="s1">&#39;ERA5 data&#39;</span><span class="p">)</span>

    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pres&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;hPa&#39;</span>
    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;temp_mean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span>
    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;temp_min&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span>
    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;temp_max&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span>

    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Model_STP_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">coldata</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Model_STP_corr_info&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_str</span>
    <span class="k">return</span> <span class="n">coldata</span></div>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyaerocom</span> <span class="k">as</span> <span class="nn">pya</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

    <span class="n">obsdata</span> <span class="o">=</span> <span class="n">pya</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadUngridded</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;EBASMC&#39;</span><span class="p">,</span> <span class="s1">&#39;ac550aer&#39;</span><span class="p">)</span>

    <span class="c1"># update unit to wrong unit</span>
    <span class="n">obsdata</span><span class="o">.</span><span class="n">check_convert_var_units</span><span class="p">(</span><span class="s1">&#39;ac550aer&#39;</span><span class="p">,</span> <span class="s1">&#39;m-1&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">obsdata</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="s1">&#39;ac550aer&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, MET Norway

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>