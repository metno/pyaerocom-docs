

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyaerocom.griddeddata &mdash; pyaerocom  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="pyaerocom  documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> pyaerocom
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#website-and-code-documentation">Website and code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#requirements">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#access-to-users-database">Access to users database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#getting-started">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials (Jupyter Notebooks)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html#further-tutorials-in-depth">Further tutorials (in-depth)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_testsuite.html">Tests (for developers)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config_files.html">Configuration files</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyaerocom</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pyaerocom.griddeddata</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyaerocom.griddeddata</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Pyaerocom GriddedData class</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="n">od</span>
<span class="kn">import</span> <span class="nn">iris</span>
<span class="kn">from</span> <span class="nn">iris.analysis.cartography</span> <span class="k">import</span> <span class="n">area_weights</span>
<span class="kn">from</span> <span class="nn">iris.analysis</span> <span class="k">import</span> <span class="n">MEAN</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">Series</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="k">import</span> <span class="n">const</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">print_log</span>

<span class="kn">from</span> <span class="nn">pyaerocom.exceptions</span> <span class="k">import</span> <span class="p">(</span><span class="n">DataExtractionError</span><span class="p">,</span>
                                  <span class="n">TemporalResolutionError</span><span class="p">,</span>
                                  <span class="n">DimensionOrderError</span><span class="p">,</span>
                                  <span class="n">NDimError</span><span class="p">,</span> <span class="n">DataDimensionError</span><span class="p">,</span>
                                  <span class="n">VariableDefinitionError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyaerocom.helpers</span> <span class="k">import</span> <span class="p">(</span><span class="n">get_time_constraint</span><span class="p">,</span> 
                               <span class="n">cftime_to_datetime64</span><span class="p">,</span>
                               <span class="n">str_to_iris</span><span class="p">,</span>
                               <span class="n">IRIS_AGGREGATORS</span><span class="p">,</span>
                               <span class="n">to_pandas_timestamp</span><span class="p">,</span>
                               <span class="n">TS_TYPE_TO_NUMPY_FREQ</span><span class="p">,</span>
                               <span class="n">datetime2str</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyaerocom.mathutils</span> <span class="k">import</span> <span class="n">closest_index</span>
<span class="kn">from</span> <span class="nn">pyaerocom.stationdata</span> <span class="k">import</span> <span class="n">StationData</span>
<span class="kn">from</span> <span class="nn">pyaerocom.region</span> <span class="k">import</span> <span class="n">Region</span>


<div class="viewcode-block" id="GriddedData"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData">[docs]</a><span class="k">class</span> <span class="nc">GriddedData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class representing model data</span>
<span class="sd">    </span>
<span class="sd">    This class is largely based on the :class:`iris.Cube` object. However, this</span>
<span class="sd">    object comes with an expanded functionality for convenience, for instance, </span>
<span class="sd">    netCDF files can directly be loaded in the :class:`GriddedData` object,</span>
<span class="sd">    whereas :class:`iris.cube.Cube` instances are typically created using</span>
<span class="sd">    helper methods such as</span>
<span class="sd">    </span>
<span class="sd">    1. :func:`iris.load` (returns </span>
<span class="sd">    :class:`iris.cube.CubeList`, i.e. a list-like iterable object that contains </span>
<span class="sd">    instances of :class:`Cube` objects, one for each variable) or </span>
<span class="sd">    </span>
<span class="sd">    2. :func:`iris.load_cube` which directly returns a :class:`iris.cube.Cube` </span>
<span class="sd">    instance and typically requires specification of a variable constraint.</span>
<span class="sd">    </span>
<span class="sd">    The :class:`GriddedData` object represents one variable in space and time, as</span>
<span class="sd">    well as corresponding meta information. Since it is based on the https://github.com/SciTools/iris/issues/1977</span>
<span class="sd">    :class:`iris.cube.Cube` it is optimised for netCDF files that follow the</span>
<span class="sd">    CF conventions and may not work for files that do not follow this standard.</span>
<span class="sd">       </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : :obj:`str:` or :obj:`Cube`</span>
<span class="sd">        data input. Can be a single .nc file or a preloaded iris Cube.</span>
<span class="sd">    var_name : :obj:`str`, optional</span>
<span class="sd">        variable name that is extracted if `input` is a file path. Irrelevant</span>
<span class="sd">        if `input` is preloaded Cube</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from pyaerocom.io.testfiles import get</span>
<span class="sd">    &gt;&gt;&gt; files = get()</span>
<span class="sd">    &gt;&gt;&gt; data = GriddedData(files[&#39;models&#39;][&#39;aatsr_su_v4.3&#39;], </span>
<span class="sd">    ...                    var_name=&quot;od550aer&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(data.var_name)</span>
<span class="sd">    od550aer</span>
<span class="sd">    &gt;&gt;&gt; print(type(data.longitude))</span>
<span class="sd">    &lt;class &#39;iris.coords.DimCoord&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(data.longitude.points.min(), data.longitude.points.max())</span>
<span class="sd">    -179.5 179.5</span>
<span class="sd">    &gt;&gt;&gt; print(data.latitude.points.min(), data.latitude.points.max())</span>
<span class="sd">    -89.5 89.5</span>
<span class="sd">    &gt;&gt;&gt; print(data.time.points.min(), data.time.points.max())</span>
<span class="sd">    0.0 365.0</span>
<span class="sd">    &gt;&gt;&gt; tstamps = data.time_stamps()</span>
<span class="sd">    &gt;&gt;&gt; print(tstamps[0], tstamps[-1])</span>
<span class="sd">    2008-01-01T00:00:00.000000 2008-12-31T00:00:00.000000</span>
<span class="sd">    &gt;&gt;&gt; data_cropped = data.crop(lat_range=(-60, 60), lon_range=(160, 180),</span>
<span class="sd">    ...                          time_range=(&quot;2008-02-01&quot;, &quot;2008-02-15&quot;))</span>
<span class="sd">    &gt;&gt;&gt; print(data_cropped.shape)</span>
<span class="sd">    (15, 120, 20)</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    grid</span>
<span class="sd">        underlying data type (hopefully :class:`iris.cube.Cube` in most cases)</span>
<span class="sd">    suppl_info : dict</span>
<span class="sd">        dictionary containing supplementary information about this data</span>
<span class="sd">        object (these may be attributes that are not already stored within</span>
<span class="sd">        the metadata representation of the underlying data object)</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_grid</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_GRID_IO</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">GRID_IO</span>
    <span class="c1">#: Req. order of dimension coordinates for time-series computation</span>
    <span class="n">COORDS_ORDER_TSERIES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]</span>
    <span class="n">_MAX_SIZE_GB</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1">#maximum file size for in-memory operations</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convert_unit_on_init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">suppl_info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span> <span class="o">=</span> <span class="n">od</span><span class="p">(</span><span class="n">from_files</span>     <span class="o">=</span> <span class="p">[],</span>
                             <span class="n">name</span>           <span class="o">=</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">,</span>
                             <span class="n">ts_type</span>        <span class="o">=</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">,</span>
                             <span class="n">regridded</span>      <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">computed</span>       <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                             <span class="n">region</span>         <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
        
        
        <span class="c1">#attribute used to store area weights (if applicable, see method</span>
        <span class="c1">#area_weights)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">input</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_input</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">suppl_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                
        <span class="k">if</span> <span class="n">convert_unit_on_init</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_info</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">has_unit</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Converting unit of data&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">convert_unit</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">VariableDefinitionError</span><span class="p">,</span> <span class="ne">MemoryError</span><span class="p">):</span>
                <span class="k">pass</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_revision</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Revision string from file Revision.txt in the main data directory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">:</span>
            <span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">revision_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">REVISION_FILE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">revision_file</span><span class="p">):</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">revision_file</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">in_file</span><span class="p">:</span>
                    <span class="n">revision</span> <span class="o">=</span> <span class="n">in_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">in_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
                <span class="k">return</span> <span class="n">revision</span>
        <span class="k">return</span> <span class="s1">&#39;n/a&#39;</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unit of data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">units</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print information about variable&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">const</span><span class="o">.</span><span class="n">VAR_PARAM</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ts_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Temporal resolution&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">[</span><span class="s1">&#39;ts_type&#39;</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">TS_TYPES</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List with valid filename encryptions specifying temporal resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_opts</span><span class="o">.</span><span class="n">GRID_IO</span><span class="o">.</span><span class="n">TS_TYPES</span>
      
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">from_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of file paths from which this data object was created&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">[</span><span class="s1">&#39;from_files&#39;</span><span class="p">]</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flag specifying whether data is masked or not</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method only works if the data is loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Information cannot be accessed. Data is not &quot;</span>
                                 <span class="s2">&quot;available in memory (lazy loading)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start time of dataset as datetime64 object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Start time could not be accessed in GriddedData&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dtype_appr</span> <span class="o">=</span> <span class="s1">&#39;datetime64[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">TS_TYPE_TO_NUMPY_FREQ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">])</span>
            <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_appr</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Failed to round start time </span><span class="si">{}</span><span class="s1"> to beginning of &#39;</span>
                             <span class="s1">&#39;frequency </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[us]&#39;</span><span class="p">)</span>

    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start time of dataset as datetime64 object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Stop time could not be accessed in GriddedData&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">TS_TYPE_TO_NUMPY_FREQ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">]</span>
            <span class="n">dtype_appr</span> <span class="o">=</span> <span class="s1">&#39;datetime64[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
            
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_appr</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[us]&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;us&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Failed to round start time </span><span class="si">{}</span><span class="s1"> to beggining of &#39;</span>
                             <span class="s1">&#39;frequency </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[us]&#39;</span><span class="p">)</span>
    
<span class="c1"># =============================================================================</span>
<span class="c1">#     @property</span>
<span class="c1">#     def longitude(self):</span>
<span class="c1">#         &quot;&quot;&quot;Longitudes of data&quot;&quot;&quot;</span>
<span class="c1">#         if self.is_cube:</span>
<span class="c1">#             return self.grid.coord(&quot;longitude&quot;)</span>
<span class="c1">#         </span>
<span class="c1">#     @longitude.setter</span>
<span class="c1">#     def longitude(self, value):</span>
<span class="c1">#         raise AttributeError(&quot;Longitudes cannot be changed, please check &quot;</span>
<span class="c1">#                              &quot;underlying data type stored in attribute grid&quot;)</span>
<span class="c1">#     </span>
<span class="c1">#     @property</span>
<span class="c1">#     def latitude(self):</span>
<span class="c1">#         &quot;&quot;&quot;Latitudes of data&quot;&quot;&quot;</span>
<span class="c1">#         if self.is_cube:</span>
<span class="c1">#             return self.grid.coord(&quot;latitude&quot;)</span>
<span class="c1">#         </span>
<span class="c1">#     @latitude.setter</span>
<span class="c1">#     def latitude(self, value):</span>
<span class="c1">#         raise AttributeError(&quot;Latitudes cannot be changed, please check &quot;</span>
<span class="c1">#                              &quot;underlying data type stored in attribute grid&quot;)</span>
<span class="c1"># =============================================================================</span>
        
<span class="c1"># =============================================================================</span>
<span class="c1">#     @property</span>
<span class="c1">#     def time(self):</span>
<span class="c1">#         &quot;&quot;&quot;Time dimension of data&quot;&quot;&quot;</span>
<span class="c1">#         if self.is_cube:</span>
<span class="c1">#             return self.grid.coord(&quot;time&quot;)</span>
<span class="c1">#         </span>
<span class="c1">#     @time.setter</span>
<span class="c1">#     def time(self, value):</span>
<span class="c1">#         raise AttributeError(&quot;Time array cannot be changed, please check &quot;</span>
<span class="c1">#                              &quot;underlying data type stored in attribute grid&quot;)</span>
<span class="c1"># =============================================================================</span>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Underlying grid data object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span>
    
    <span class="nd">@grid</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Grid data format </span><span class="si">%s</span><span class="s2"> is not supported, need Cube&quot;</span> 
                            <span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">value</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of variable in grid&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;n/a&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">var_name</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plot_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`Variable` instance that contains plot settings</span>
<span class="sd">        </span>
<span class="sd">        The settings can be specified in the variables.ini file based on the</span>
<span class="sd">        unique var_name, see e.g. `here &lt;http://aerocom.met.no/pyaerocom/</span>
<span class="sd">        config_files.html#variables&gt;`__</span>
<span class="sd">        </span>
<span class="sd">        If no default settings can be found for this variable, all parameters</span>
<span class="sd">        will be initiated with ``None``, in which case the Aerocom plot method</span>
<span class="sd">        uses</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">const</span><span class="o">.</span><span class="n">VAR_PARAM</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span>
            
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ID of model to which data belongs&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if underlying data type is of type :class:`iris.cube.Cube`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_climatology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">year</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
            <span class="k">if</span> <span class="n">year</span> <span class="o">==</span> <span class="mi">9999</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="n">pd</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if grid data is available (:attr:`grid` =! None)</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Since so far, the only supported type is :class:`iris.cube.Cube`, this</span>
<span class="sd">        method simply returns :attr:`is_cube`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No data available...&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span> 
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lon_res</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Data does not contain longitude information&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Check longitudes&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lat_res</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Data does not contain longitude information&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Check latitudes&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No data available...&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ndim</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array containing the order of coordinates&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span>    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coord_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List containing coordinate names&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="p">()]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimcoord_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List containing coordinate names&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_area_weights</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span>
    
    <span class="nd">@area_weights</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">area_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Area weights cannot be set manually yet...&quot;</span><span class="p">)</span>
      
<div class="viewcode-block" id="GriddedData.check_dim_coords"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_dim_coords">[docs]</a>    <span class="k">def</span> <span class="nf">check_dim_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check dimension coordinates of grid data&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
        
<div class="viewcode-block" id="GriddedData.load_input"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.load_input">[docs]</a>    <span class="k">def</span> <span class="nf">load_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Import input as cube</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input : :obj:`str:` or :obj:`Cube`</span>
<span class="sd">            data input. Can be a single .nc file or a preloaded iris Cube.</span>
<span class="sd">        var_name : :obj:`str`, optional</span>
<span class="sd">            variable name that is extracted if `input` is a file path . Irrelevant</span>
<span class="sd">            if `input` is preloaded Cube</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="nb">input</span> <span class="c1">#instance of Cube</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pyaerocom.io.iris_io</span> <span class="k">import</span> <span class="n">load_cube_custom</span>
            <span class="kn">from</span> <span class="nn">pyaerocom.io</span> <span class="k">import</span> <span class="n">FileConventionRead</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">load_cube_custom</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">FileConventionRead</span><span class="p">()</span>
                <span class="n">f</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">f</span><span class="o">.</span><span class="n">get_info_from_file</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">[</span><span class="s2">&quot;from_files&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Failed to load input: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">var_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_info</span><span class="o">.</span><span class="n">var_name</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Failed to convert variable name </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">))</span></div>
        
     
<div class="viewcode-block" id="GriddedData.convert_unit"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.convert_unit">[docs]</a>    <span class="k">def</span> <span class="nf">convert_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert unit of data to new unit&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size_GB</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAX_SIZE_GB</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s1">&#39;Cannot convert unit in </span><span class="si">{}</span><span class="s1"> since data is too &#39;</span>
                              <span class="s1">&#39;large (</span><span class="si">{}</span><span class="s1"> GB)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size_GB</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">new_unit</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="GriddedData.time_stamps"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.time_stamps">[docs]</a>    <span class="k">def</span> <span class="nf">time_stamps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert time stamps into list of numpy datetime64 objects</span>
<span class="sd">        </span>
<span class="sd">        The conversion is done using method :func:`cfunit_to_datetime64`</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list </span>
<span class="sd">            list containing all time stamps as datetime64 objects </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span><span class="p">:</span>    
            <span class="k">return</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.check_coord_order"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_coord_order">[docs]</a>    <span class="k">def</span> <span class="nf">check_coord_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrapper for :func:`check_dimcoords_tseries`&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;Method was renamed, please use &#39;</span>
                                       <span class="s1">&#39;check_dimcoords_tseries&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="GriddedData.check_dimcoords_tseries"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_dimcoords_tseries">[docs]</a>    <span class="k">def</span> <span class="nf">check_dimcoords_tseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check order of dimension coordinates for time series retrieval</span>
<span class="sd">        </span>
<span class="sd">        For computation of time series at certain lon / lat coordinates, the </span>
<span class="sd">        data dimensions have to be in a certain order specified by </span>
<span class="sd">        :attr:`COORDS_ORDER_TSERIES`.</span>
<span class="sd">        </span>
<span class="sd">        This method checks the current order (and dimensionality) of data and</span>
<span class="sd">        raises appropriate errors.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NDimError</span>
<span class="sd">            if dimension of data is not supported (currently, 3D or 4D data</span>
<span class="sd">            is supported)</span>
<span class="sd">        DimensionOrderError</span>
<span class="sd">            if dimensions are not in the right order (in which case </span>
<span class="sd">            :func:`reorder_dimensions_tseries` may be used to catch the </span>
<span class="sd">            Exception)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COORDS_ORDER_TSERIES</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NDimError</span><span class="p">(</span><span class="s1">&#39;Time series extraction requires at least 3 &#39;</span>
                            <span class="s1">&#39;coordinates in cube&#39;</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">check</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;One of the data dimension coordinates &#39;</span>
                                     <span class="s1">&#39;may not be defined&#39;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">check</span><span class="p">[:</span><span class="mi">3</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span> <span class="o">==</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">DimensionOrderError</span><span class="p">(</span><span class="s1">&#39;Invalid order of grid &#39;</span>
                                          <span class="s1">&#39;dimension, need </span><span class="si">{}</span><span class="s1">, got </span><span class="si">{}</span><span class="s1">&#39;</span>
                                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">,</span>
                                                  <span class="n">check</span><span class="p">))</span></div>
        
            
<div class="viewcode-block" id="GriddedData.reorder_dimensions_tseries"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.reorder_dimensions_tseries">[docs]</a>    <span class="k">def</span> <span class="nf">reorder_dimensions_tseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorders dimensions of data such that :func:`to_time_series` works</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COORDS_ORDER_TSERIES</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">new_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_order</span><span class="p">:</span>
                    <span class="n">new_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="GriddedData.transpose"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Re-order data dimensions in object</span>
<span class="sd">        </span>
<span class="sd">        Wrapper for :func:`iris.cube.Cube.transpoe`</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Changes THIS object (i.e. no new instance of :class:`GriddedData` will </span>
<span class="sd">        be created)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : list</span>
<span class="sd">            new index order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span></div>
        
    <span class="k">def</span> <span class="nf">_check_altitude_access</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">coord_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">coord_name</span> <span class="o">==</span> <span class="s1">&#39;altitude&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.vert_coords</span> <span class="k">import</span> <span class="n">_VertCoordConverter</span> <span class="k">as</span> <span class="n">conv</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">conv</span><span class="o">.</span><span class="n">supported</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">arg_info</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">VARS</span><span class="p">[</span><span class="n">coord_name</span><span class="p">]</span>
        <span class="n">args_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">name1</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">possible_vals</span> <span class="ow">in</span> <span class="n">arg_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">pass</span>
            
        
        
<div class="viewcode-block" id="GriddedData.get_altitude"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.get_altitude">[docs]</a>    <span class="k">def</span> <span class="nf">get_altitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract (or try to compute) altitude values at input coordinates&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Coming soon...&#39;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="GriddedData.to_time_series"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.to_time_series">[docs]</a>    <span class="k">def</span> <span class="nf">to_time_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> 
                       <span class="n">collapse_scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vert_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">coords</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Extract time-series for provided input coordinates (lon, lat)</span>

<span class="sd">        Extract time series for each lon / lat coordinate in this cube or at</span>
<span class="sd">        predefined sample points (e.g. station data). If sample points are</span>
<span class="sd">        provided, the cube is interpolated first onto the sample points.</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Check Memory error handle</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            coordinates (e.g. lon / lat) at which time series is supposed to be</span>
<span class="sd">            retrieved</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme (for details, see :func:`interpolate`)</span>
<span class="sd">        collapse_scalar : bool</span>
<span class="sd">            see :func:`interpolate`</span>
<span class="sd">        vert_scheme : str</span>
<span class="sd">            string specifying how to treat vertical coordinates. This is only</span>
<span class="sd">            relevant for data that contains vertical levels. It will be ignored</span>
<span class="sd">            otherwise. Note that if the input coordinate specifications contain</span>
<span class="sd">            altitude information, this parameter will be set automatically to</span>
<span class="sd">            &#39;altitude&#39;. Allowed inputs are all data collapse schemes that </span>
<span class="sd">            are supported by :func:`pyaerocom.helpers.str_to_iris` (e.g. `mean, </span>
<span class="sd">            median, sum`). Further valid schemes are `altitude, surface, </span>
<span class="sd">            profile`.</span>
<span class="sd">            If not other specified and if `altitude` coordinates are provided</span>
<span class="sd">            via sample_points (or **coords parameters) then, vert_scheme will </span>
<span class="sd">            be set to `altitude`. Else, `profile` is used.</span>
<span class="sd">        **coords</span>
<span class="sd">            additional keyword args that may be used to provide the interpolation</span>
<span class="sd">            coordinates (for details, see :func:`interpolate`)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of result dictionaries for each coordinate. Dictionary keys</span>
<span class="sd">            are: ``longitude, latitude, var_name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>
        <span class="c1"># if the method makes it to this point, the it is 3 or 4 dimensional </span>
        <span class="c1"># and the first 3 dimensions are time, latitude, longitude.</span>
        
        <span class="c1"># init input for sample points</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sample_points</span><span class="p">:</span>
            <span class="n">sample_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sample_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_points</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lens</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arrays for sample coordinates must have the &quot;</span>
                             <span class="s2">&quot;same lengths&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1">#data does not contain vertical dimension</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_timeseries_2D</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span>
                                          <span class="n">collapse_scalar</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_timeseries_3D</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> 
                                      <span class="n">collapse_scalar</span><span class="p">,</span> <span class="n">vert_scheme</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_to_timeseries_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract time-series for provided input coordinates (lon, lat)</span>
<span class="sd">        </span>
<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Check Memory error handle</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            coordinates (e.g. lon / lat) at which time series is supposed to be</span>
<span class="sd">            retrieved</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme (for details, see :func:`interpolate`)</span>
<span class="sd">        collapse_scalar : bool</span>
<span class="sd">            see :func:`interpolate`</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of result dictionaries for each coordinate. Dictionary keys</span>
<span class="sd">            are: ``longitude, latitude, var_name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Developers: Debug! Users: please contact &#39;</span>
                            <span class="s1">&#39;developers :)&#39;</span><span class="p">)</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_points</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;latitude&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_points</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;longitude&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="n">grid_lons</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lats</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">grid_lons</span><span class="o">==</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">data</span> <span class="o">=</span> <span class="n">StationData</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> 
                               <span class="n">longitude</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span>
                               <span class="n">dataset_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            
            <span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_check_vert_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">vert_scheme</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method that checks and infers vertical scheme for time</span>
<span class="sd">        series computation from 3D data (used in :func:`_to_timeseries_3D`)&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="k">import</span> <span class="n">vert_coords</span> <span class="k">as</span> <span class="n">vc</span>
        <span class="k">if</span> <span class="s1">&#39;altitude&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">sample_points</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_altitude_access</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Cannot access altitude &#39;</span>
                                         <span class="s1">&#39;information&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vert_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vert_scheme</span><span class="o">==</span><span class="s1">&#39;altitude&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Conflict: Input sample points include &#39;</span> 
                                     <span class="s1">&#39;altitude information but input for &#39;</span>
                                     <span class="s1">&#39;vert_scheme is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vert_scheme</span><span class="p">))</span>
            <span class="n">vert_scheme</span> <span class="o">=</span> <span class="s1">&#39;altitude&#39;</span>
        <span class="k">elif</span> <span class="n">vert_scheme</span> <span class="o">==</span> <span class="s1">&#39;surface&#39;</span><span class="p">:</span>
            <span class="c1">#presume data dimensions have been sorted</span>
            <span class="n">cname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>        
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vc</span><span class="o">.</span><span class="n">supported</span><span class="p">(</span><span class="n">cname</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Vertical dimension coordinate </span><span class="si">{}</span><span class="s1"> is &#39;</span>
                                         <span class="s1">&#39;not supported. Cannot infer surface &#39;</span>
                                         <span class="s1">&#39;level&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cname</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">vert_scheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vert_scheme</span> <span class="o">=</span><span class="s1">&#39;mean&#39;</span>
        <span class="k">return</span> <span class="n">vert_scheme</span>
    
    <span class="k">def</span> <span class="nf">_to_timeseries_3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="p">,</span>
                          <span class="n">vert_scheme</span><span class="o">=</span><span class="s1">&#39;profile&#39;</span><span class="p">):</span>

        <span class="c1"># data contains vertical dimension</span>
        <span class="n">vert_scheme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_vert_scheme</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">vert_scheme</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vert_scheme</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;altitude&#39;</span><span class="p">,</span> <span class="s1">&#39;profile&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Coming soon...&#39;</span><span class="p">)</span>
        <span class="n">cname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># check if vertical scheme can be converted into valid iris </span>
            <span class="c1"># aggregator (in which case vertical dimension is collopsed)</span>
            <span class="n">aggr</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">vert_scheme</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">cname</span><span class="p">,</span> <span class="n">aggr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="k">import</span> <span class="n">vert_coords</span> <span class="k">as</span> <span class="n">vc</span>
            <span class="k">if</span> <span class="n">vert_scheme</span> <span class="o">==</span> <span class="s1">&#39;surface&#39;</span><span class="p">:</span>
                <span class="n">cname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">VerticalCoordinate</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">lev_increases_with_alt</span><span class="p">:</span>
                    <span class="n">vert_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vert_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:,:,</span><span class="n">vert_index</span><span class="p">]</span>
        
                    
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to_time_series</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> 
                                   <span class="n">collapse_scalar</span><span class="p">)</span>
        
<div class="viewcode-block" id="GriddedData.to_time_series_single_coord"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.to_time_series_single_coord">[docs]</a>    <span class="k">def</span> <span class="nf">to_time_series_single_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make time series dictionary of single location using neirest coordinate</span>
<span class="sd">        </span>
<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Crop before extraction</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latitude : float</span>
<span class="sd">            latitude of coordinate</span>
<span class="sd">        longitude : float</span>
<span class="sd">            longitude of coordinate</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            dictionary containing results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NDimError</span><span class="p">(</span><span class="s1">&#39;So far, timeseries can only be extracted &#39;</span>
                            <span class="s1">&#39;from 3 dimensional data...&#39;</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">lon_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lons</span> <span class="o">-</span> <span class="n">longitude</span><span class="p">))</span>
        <span class="n">lat_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lats</span> <span class="o">-</span> <span class="n">latitude</span><span class="p">))</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">lat_idx</span><span class="p">,</span> <span class="n">lon_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;latitude&#39;</span>      <span class="p">:</span> <span class="n">latitude</span><span class="p">,</span> 
                <span class="s1">&#39;longitude&#39;</span>     <span class="p">:</span> <span class="n">longitude</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>   <span class="p">:</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="p">)}</span></div>
        
    <span class="c1"># TODO: Test, confirm and remove beta flag in docstring</span>
<div class="viewcode-block" id="GriddedData.downscale_time"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.downscale_time">[docs]</a>    <span class="k">def</span> <span class="nf">downscale_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_ts_type</span><span class="o">=</span><span class="s1">&#39;monthly&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Downscale in time to predefined resolution resolution</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Beta version</span>
<span class="sd">        </span>
<span class="sd">        Patameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_ts_type : str</span>
<span class="sd">            either of the supported temporal resolutions (cf. </span>
<span class="sd">            :attr:`IRIS_AGGREGATORS` in :mod:`helpers`, e.g. &quot;monthly&quot;)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing downscaled data</span>
<span class="sd">            </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TemporalResolutionError</span>
<span class="sd">            if input resolution is not provided, or if it is higher temporal </span>
<span class="sd">            resolution than this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts_types_avail</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">GRID_IO</span><span class="o">.</span><span class="n">TS_TYPES</span>
        <span class="n">idx_ts_type</span> <span class="o">=</span> <span class="n">ts_types_avail</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span> <span class="o">==</span> <span class="n">to_ts_type</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data is already in </span><span class="si">{}</span><span class="s1"> resolution&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_ts_type</span> <span class="ow">in</span> <span class="n">IRIS_AGGREGATORS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TemporalResolutionError</span><span class="p">(</span><span class="s1">&#39;Resolution </span><span class="si">{}</span><span class="s1"> cannot &#39;</span>
                <span class="s1">&#39;converted&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">ts_types_avail</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">idx_ts_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TemporalResolutionError</span><span class="p">(</span><span class="s1">&#39;Cannot increase &#39;</span>
                <span class="s1">&#39;temporal resolution from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">,</span>
                                          <span class="n">to_ts_type</span><span class="p">))</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">to_ts_type</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">()]):</span>
            <span class="n">IRIS_AGGREGATORS</span><span class="p">[</span><span class="n">to_ts_type</span><span class="p">](</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">to_ts_type</span><span class="p">)</span>
        
        <span class="n">aggregated</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">,</span> <span class="n">MEAN</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">aggregated</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">[</span><span class="s1">&#39;ts_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_ts_type</span>
        <span class="k">return</span> <span class="n">data</span>     </div>
    
<div class="viewcode-block" id="GriddedData.calc_area_weights"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.calc_area_weights">[docs]</a>    <span class="k">def</span> <span class="nf">calc_area_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate area weights for grid&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_lonlat_bounds</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span> <span class="o">=</span> <span class="n">area_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_weights</span></div>
                
<div class="viewcode-block" id="GriddedData.crop"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.crop">[docs]</a>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lat_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
             <span class="n">time_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;High level function that applies cropping along multiple axes</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">            1. For cropping of longitudes and latitudes, the method </span>
<span class="sd">            :func:`iris.cube.Cube.intersection` is used since it automatically </span>
<span class="sd">            accepts and understands longitude input based on definition </span>
<span class="sd">            0 &lt;= lon &lt;= 360 as well as for -180 &lt;= lon &lt;= 180</span>
<span class="sd">            2. Time extraction may be provided directly as index or in form of</span>
<span class="sd">            :class:`pandas.Timestamp` objects. </span>
<span class="sd">            </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon_range : :obj:`tuple`, optional</span>
<span class="sd">            2-element tuple containing longitude range for cropping. If None, </span>
<span class="sd">            the longitude axis remains unchanged. </span>
<span class="sd">            Example input to crop around meridian: `lon_range=(-30, 30)`</span>
<span class="sd">        lat_range : :obj:`tuple`, optional</span>
<span class="sd">            2-element tuple containing latitude range for cropping. If None, </span>
<span class="sd">            the latitude axis remains unchanged</span>
<span class="sd">        time_range : :obj:`tuple`, optional</span>
<span class="sd">            2-element tuple containing time range for cropping. Allowed data</span>
<span class="sd">            types for specifying the times are </span>
<span class="sd">            </span>
<span class="sd">                1. a combination of 2 :class:`pandas.Timestamp` instances or </span>
<span class="sd">                2. a combination of two strings that can be directly converted\</span>
<span class="sd">                into :class:`pandas.Timestamp` instances (e.g.\</span>
<span class="sd">                `time_range=(&quot;2010-1-1&quot;, &quot;2012-1-1&quot;)`) or</span>
<span class="sd">                3. directly a combination of indices (:obj:`int`). </span>
<span class="sd">            </span>
<span class="sd">            If None, the time axis remains unchanged.</span>
<span class="sd">        region : :obj:`str` or :obj:`Region`, optional</span>
<span class="sd">            string ID of pyaerocom default region or directly an instance of </span>
<span class="sd">            the :class:`Region` object. May be used instead of </span>
<span class="sd">            ``lon_range`` and ``lat_range``, if these are unspecified.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing cropped grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This feature is only available if the&quot;</span>
                                      <span class="s2">&quot;underlying data is of type iris.Cube&quot;</span><span class="p">)</span>
        <span class="n">suppl</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">suppl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">region</span> <span class="o">=</span> <span class="n">Region</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to access longitude / latitude range &quot;</span>
                                   <span class="s2">&quot;using region ID </span><span class="si">{}</span><span class="s2">. Error msg: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                           <span class="n">region</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">Region</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid input for region&quot;</span><span class="p">)</span>
            <span class="n">suppl</span><span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span>
            <span class="n">lon_range</span><span class="p">,</span> <span class="n">lat_range</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">lon_range</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">lat_range</span>
        <span class="k">if</span> <span class="n">lon_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lat_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">longitude</span><span class="o">=</span><span class="n">lon_range</span><span class="p">,</span> 
                                          <span class="n">latitude</span><span class="o">=</span><span class="n">lat_range</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lon_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lat_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">longitude</span><span class="o">=</span><span class="n">lon_range</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lon_range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lat_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lat_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s2">&quot;Failed to apply spatial cropping...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">suppl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">):</span>
                <span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                              <span class="n">Timestamp</span><span class="p">(</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cropping along time axis based on Timestamps&quot;</span><span class="p">)</span>
                <span class="n">time_constraint</span> <span class="o">=</span> <span class="n">get_time_constraint</span><span class="p">(</span><span class="o">*</span><span class="n">time_range</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">time_constraint</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cropping along time axis based on indices&quot;</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s2">&quot;Failed to apply temporal cropping&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">suppl</span><span class="p">)</span></div>
        
    
<div class="viewcode-block" id="GriddedData.area_weighted_mean"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.area_weighted_mean">[docs]</a>    <span class="k">def</span> <span class="nf">area_weighted_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get area weighted mean&quot;&quot;&quot;</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_weights</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">],</span> 
                              <span class="n">aggregator</span><span class="o">=</span><span class="n">MEAN</span><span class="p">,</span> 
                              <span class="n">weights</span><span class="o">=</span><span class="n">ws</span><span class="p">)</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span></div>
        
    <span class="c1"># redefined methods from iris.Cube class. This includes all Cube </span>
    <span class="c1"># processing methods that exist in the Cube class and that work on the </span>
    <span class="c1"># Cube and return a Cube instance. These may be expanded (e.g. for </span>
    <span class="c1"># instance what they accept as input</span>
    
<div class="viewcode-block" id="GriddedData.aerocom_filename"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.aerocom_filename">[docs]</a>    <span class="k">def</span> <span class="nf">aerocom_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at_stations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filename of data following Aerocom 3 conventions</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        at_stations : str</span>
<span class="sd">            if True, then AtStations string will be included in filename</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            generated file name based on what is in this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io</span> <span class="k">import</span> <span class="n">FileConventionRead</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fconv</span> <span class="o">=</span> <span class="n">FileConventionRead</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">base_info</span> <span class="o">=</span> <span class="n">fconv</span><span class="o">.</span><span class="n">get_info_from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
        <span class="n">vert_pos</span> <span class="o">=</span> <span class="n">base_info</span><span class="p">[</span><span class="s1">&#39;vert_pos&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vert_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vert_pos</span> <span class="o">=</span> <span class="s1">&#39;UNDEFINED&#39;</span>
        <span class="k">if</span> <span class="n">at_stations</span><span class="p">:</span>
            <span class="n">vert_pos</span> <span class="o">+=</span> <span class="s1">&#39;AtStations&#39;</span>
            
        <span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="n">fconv</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">vert_pos</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">year</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fconv</span><span class="o">.</span><span class="n">file_sep</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nc&#39;</span></div>
    
<div class="viewcode-block" id="GriddedData.compute_at_stations_file"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.compute_at_stations_file">[docs]</a>    <span class="k">def</span> <span class="nf">compute_at_stations_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stat_lats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stat_lons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">obs_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates and saves new netcdf file at input lat / lon coordinates</span>
<span class="sd">        </span>
<span class="sd">        This method can be used to reduce the size of too large grid files.</span>
<span class="sd">        It reduces the lon / lat dimensionality corresponding to the locations</span>
<span class="sd">        of the input lat / lon coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stat_lats </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="k">import</span> <span class="n">UngriddedData</span><span class="p">,</span> <span class="n">print_log</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing AtStations file. This may take a while&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_data</span><span class="p">,</span> <span class="n">UngriddedData</span><span class="p">):</span>
            <span class="n">stat_lons</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">longitude</span>
            <span class="n">stat_lats</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">latitude</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">stat_lons</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">stat_lats</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Longitude and latitude arrays need to have the &#39;</span>
                             <span class="s1">&#39;same length (since they are supposed to belong) &#39;</span>
                             <span class="s1">&#39;to station_coordinates&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_dir</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CACHEDIR</span>
        <span class="k">if</span> <span class="n">savename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">savename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aerocom_filename</span><span class="p">(</span><span class="n">at_stations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>
        
        <span class="n">lon_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lat_idx</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stat_lats</span><span class="p">,</span> <span class="n">stat_lons</span><span class="p">):</span>
            <span class="n">lon_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_index</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lon</span><span class="p">))</span>
            <span class="n">lat_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_index</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span>
        
        <span class="n">lon_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">lon_idx</span><span class="p">))</span>
        <span class="n">lat_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">lat_idx</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>
          
        <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span> <span class="n">lat_idx</span><span class="p">][:,:,</span><span class="n">lon_idx</span><span class="p">]</span>
        <span class="c1"># make sure everything went well with the dimensions</span>
        <span class="n">subset</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">savename</span><span class="p">)</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Finished computing AtStations file.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span></div>
        
<div class="viewcode-block" id="GriddedData.to_netcdf"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.to_netcdf">[docs]</a>    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">savename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save as netcdf file</span>
<span class="sd">        </span>
<span class="sd">        Paraemeters</span>
<span class="sd">        -----------</span>
<span class="sd">        out_dir : str</span>
<span class="sd">            output direcory (must exist)</span>
<span class="sd">        savename : :obj:`str`, optional</span>
<span class="sd">            name of file. If None, :func:`aerocom_filename` is used</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            file path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">savename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">savename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aerocom_filename</span><span class="p">()</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">savename</span><span class="p">)</span>
        <span class="n">iris</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fp</span></div>
        
<div class="viewcode-block" id="GriddedData.interpolate"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> 
                    <span class="n">collapse_scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate cube at certain discrete points</span>
<span class="sd">        </span>
<span class="sd">        Reimplementation of method :func:`iris.cube.Cube.interpolate`, for </span>
<span class="sd">        details `see here &lt;http://scitools.org.uk/iris/docs/v1.10.0/iris/iris/</span>
<span class="sd">        cube.html#iris.cube.Cube.interpolate&gt;`__</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The input coordinates may also be provided using the input arg **coords</span>
<span class="sd">        which provides a more intuitive option (e.g. input</span>
<span class="sd">        ``(sample_points=[(&quot;longitude&quot;, [10, 20]), (&quot;latitude&quot;, [1, 2])])`` </span>
<span class="sd">        is the same as input</span>
<span class="sd">        ``(longitude=[10, 20], latitude=[1,2])``</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            sequence of coordinate pairs over which to interpolate</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme, pyaerocom default is Nearest. If input is </span>
<span class="sd">            string, it is converted into the corresponding iris Interpolator </span>
<span class="sd">            object, see :func:`str_to_iris` for valid strings</span>
<span class="sd">        collapse_scalar : bool</span>
<span class="sd">            Whether to collapse the dimension of scalar sample points in the</span>
<span class="sd">            resulting cube. Default is True.</span>
<span class="sd">        **coords</span>
<span class="sd">            additional keyword args that may be used to provide the interpolation</span>
<span class="sd">            coordinates in an easier way than using the ``Cube`` argument</span>
<span class="sd">            :arg:`sample_points``. May also be a combination of both.</span>
<span class="sd">         </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing interpolated data</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from pyaerocom import GriddedData</span>
<span class="sd">            &gt;&gt;&gt; data = GriddedData()</span>
<span class="sd">            &gt;&gt;&gt; data._init_testdata_default()</span>
<span class="sd">            &gt;&gt;&gt; itp = data.interpolate([(&quot;longitude&quot;, (10)),</span>
<span class="sd">            ...                         (&quot;latitude&quot; , (35))])</span>
<span class="sd">            &gt;&gt;&gt; print(itp.shape)</span>
<span class="sd">            (365, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size_GB</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAX_SIZE_GB</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s1">&#39;Data is too large (grid size: </span><span class="si">{}</span><span class="s1">, file: </span><span class="si">{}</span><span class="s1"> GB) &#39;</span>
                              <span class="s1">&#39;for interpolation (which requires loading data &#39;</span>
                              <span class="s1">&#39;into memory)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size_GB</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scheme</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sample_points</span><span class="p">:</span>
            <span class="n">sample_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sample_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Interpolating data of shape </span><span class="si">{}</span><span class="s1">. This may take a while.&#39;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">itp_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> 
                                             <span class="n">collapse_scalar</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s2">&quot;Interpolation failed since grid of interpolated &quot;</span>
                              <span class="s2">&quot;Cube is too large&quot;</span><span class="p">)</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Successfully interpolated cube&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">itp_cube</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GriddedData.regrid"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.regrid">[docs]</a>    <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;areaweighted&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regrid this grid to grid resolution of other grid</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GriddedData</span>
<span class="sd">            other data object</span>
<span class="sd">        scheme : str</span>
<span class="sd">            regridding scheme (e.g. linear, neirest, areaweighted)</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData </span>
<span class="sd">            regridded data object (new instance, this object remains unchanged)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GriddedData</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scheme</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_lonlat_bounds</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_check_lonlat_bounds</span><span class="p">()</span>
        <span class="n">data_rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">scheme</span><span class="p">)</span>
        <span class="n">suppl</span> <span class="o">=</span> <span class="n">od</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span>
        <span class="n">suppl</span><span class="p">[</span><span class="s1">&#39;regridded&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data_rg</span><span class="p">,</span> <span class="o">**</span><span class="n">suppl</span><span class="p">)</span>        </div>
    
<div class="viewcode-block" id="GriddedData.collapsed"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.collapsed">[docs]</a>    <span class="k">def</span> <span class="nf">collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collapse cube</span>
<span class="sd">        </span>
<span class="sd">        Reimplementation of method :func:`iris.cube.Cube.collapsed`, for </span>
<span class="sd">        details `see here &lt;http://scitools.org.uk/iris/docs/latest/iris/iris/</span>
<span class="sd">        cube.html#iris.cube.Cube.collapsed&gt;`__</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : str or list</span>
<span class="sd">            string IDs of coordinate(s) that are to be collapsed (e.g. </span>
<span class="sd">            ``[&quot;longitude&quot;, &quot;latitude&quot;]``)</span>
<span class="sd">        aggregator : str or Aggregator or WeightedAggretor</span>
<span class="sd">            the aggregator used. If input is string, it is converted into the</span>
<span class="sd">            corresponding iris Aggregator object, see </span>
<span class="sd">            :func:`str_to_iris` for valid strings</span>
<span class="sd">        **kwargs </span>
<span class="sd">            additional keyword args (e.g. ``weights``)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            collapsed data object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggregator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">aggregator</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">aggregator</span><span class="p">)</span>
        <span class="n">collapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">collapsed</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GriddedData.extract"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract subset</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constraint : iris.Constraint</span>
<span class="sd">            constraint that is to be applied</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing cropped data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This feature is only available if the&quot;</span>
                                      <span class="s2">&quot;underlying data is of type iris.Cube&quot;</span><span class="p">)</span>
        <span class="n">data_crop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_crop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s2">&quot;Failed to extract subset&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data_crop</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GriddedData.intersection"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ectract subset using :func:`iris.cube.Cube.intersection` </span>
<span class="sd">        </span>
<span class="sd">        See `here for details &lt;http://scitools.org.uk/iris/docs/v1.9.0/html/</span>
<span class="sd">        iris/iris/cube.html#iris.cube.Cube.intersection&gt;`__</span>
<span class="sd">        related to method and input parameters.</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Only works if underlying grid data type is :class:`iris.cube.Cube`</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args</span>
<span class="sd">            non-keyword args</span>
<span class="sd">        **kwargs</span>
<span class="sd">            keyword args</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing cropped data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cube</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This feature is only available if the&quot;</span>
                                      <span class="s2">&quot;underlying data is of type iris.Cube&quot;</span><span class="p">)</span>
        <span class="n">data_crop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data_crop</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="GriddedData.quickplot_map"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.quickplot_map">[docs]</a>    <span class="k">def</span> <span class="nf">quickplot_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a quick plot onto a map</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_idx : int</span>
<span class="sd">            index in time to be plotted</span>
<span class="sd">        xlim : tuple</span>
<span class="sd">            2-element tuple specifying plotted longitude range</span>
<span class="sd">        ylim : tuple</span>
<span class="sd">            2-element tuple specifying plotted latitude range</span>
<span class="sd">        **kwargs</span>
<span class="sd">            additional keyword arguments passed to </span>
<span class="sd">            :func:`pyaerocom.quickplot.plot_map`</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig</span>
<span class="sd">            matplotlib figure instance containing plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">time_idx</span><span class="p">)</span><span class="o">.</span><span class="n">to_datetime64</span><span class="p">()</span>
                <span class="n">time_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Failed to interpret input time stamp&#39;</span><span class="p">)</span>
        
        <span class="kn">from</span> <span class="nn">pyaerocom.plot.mapping</span> <span class="k">import</span> <span class="n">plot_griddeddata_on_map</span> 
        
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>
        
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_griddeddata_on_map</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> 
                                      <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">time_idx</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tstr</span> <span class="o">=</span> <span class="n">datetime2str</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">tstr</span> <span class="o">=</span> <span class="n">datetime2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()[</span><span class="n">time_idx</span><span class="p">],</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
                              <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">tstr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">fig</span></div>
    
<div class="viewcode-block" id="GriddedData.min"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Minimum value&quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="GriddedData.max"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum value&quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="GriddedData.mean"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mean value of data array</span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Corresponds to numerical mean of underlying N-dimensional numpy array.</span>
<span class="sd">        Does not consider area-weights or any other advanced averaging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="GriddedData.std"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Standard deviation of values&quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="GriddedData.short_str"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.short_str">[docs]</a>    <span class="k">def</span> <span class="nf">short_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Short string representation&quot;&quot;&quot;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="s2">&quot;Pyaerocom </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
             <span class="s2">&quot;Variable: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
             <span class="s2">&quot;Temporal resolution: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
             <span class="s2">&quot;Start / Stop: </span><span class="si">{}</span><span class="s2"> - </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">,</span>
                                            <span class="nb">len</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="o">*</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> 
                                            <span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">[</span><span class="s2">&quot;ts_type&quot;</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span></div>
    
    <span class="k">def</span> <span class="nf">_check_lonlat_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if longitude and latitude bounds are set and if not, guess&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">guess_bounds</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">guess_bounds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_testdata_default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method that loads ECMWF_OSUITE test data&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io.testfiles</span> <span class="k">import</span> <span class="n">get</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_input</span><span class="p">(</span><span class="n">get</span><span class="p">()[</span><span class="s2">&quot;models&quot;</span><span class="p">][</span><span class="s2">&quot;ecmwf_osuite&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;od550aer&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size_GB</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size of original data files from which this object is created</span>
<span class="sd">        </span>
<span class="sd">        These method is intended to be used for operations that actually </span>
<span class="sd">        require the *realisation* of the (lazy loaded) data. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">])</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span>
    
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        
    
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices_or_attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x.__getitem__(y) &lt;==&gt; x[y]&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">indices_or_attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">indices_or_attr</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices_or_attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;pyaerocom.GriddedData&#39; object has no &quot;</span>
                                     <span class="s2">&quot;attribute &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">suppl_info</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if variable or coordinate matchs input string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span>
     
    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span> <span class="o">+</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For now, use string representation of underlying data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;pyaerocom.GriddedData: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">Grid data: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()))</span>
    
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For now, use representation of underlying data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;pyaerocom.GriddedData</span><span class="se">\n</span><span class="s2">Grid data: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    
    <span class="c1">#sorted out</span>
    <span class="k">def</span> <span class="nf">_to_timeseries_iter_coords_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> 
                                      <span class="n">collapse_scalar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract time-series for provided input coordinates (lon, lat)</span>
<span class="sd">        </span>
<span class="sd">        This method extracts the time-series at all input coordinates by </span>
<span class="sd">        iterating over the coordinate locations, cropping the grid around the </span>
<span class="sd">        coordinate and then interpolating it using</span>
<span class="sd">        the provided interpolation scheme.</span>
<span class="sd">        </span>
<span class="sd">        This method may be faster for a small number of coordinates (compared </span>
<span class="sd">        to :func:`to_timeseries`). It may also be the better choice in case the</span>
<span class="sd">        number of coordinates is too large in which case :func:`to_time_series`</span>
<span class="sd">        may fail due to a MemoryError (i.e. the case where the final </span>
<span class="sd">        interpolated object is too large to fit into memory).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            coordinates (e.g. lon / lat) at which time series is supposed to be</span>
<span class="sd">            retrieved</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme (for details, see :func:`interpolate`)</span>
<span class="sd">        collapse_scalar : bool</span>
<span class="sd">            see :func:`interpolate`</span>
<span class="sd">        **coords</span>
<span class="sd">            additional keyword args that may be used to provide the interpolation</span>
<span class="sd">            coordinates (for details, see :func:`interpolate`)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of result dictionaries for each coordinate. Dictionary keys</span>
<span class="sd">            are: ``latitude, longitude, altitude, var_name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scheme</span><span class="o">==</span><span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        
        <span class="n">lats</span><span class="p">,</span> <span class="n">lons</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sample_points</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;latitude&#39;</span><span class="p">:</span>
                <span class="n">lats</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;longitude&#39;</span><span class="p">:</span>
                <span class="n">lons</span> <span class="o">=</span> <span class="n">vals</span>
        
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>
        <span class="n">grid_lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">grid_lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">totnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lats</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;At coord </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">totnum</span><span class="p">))</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="n">lat_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">grid_lats</span> <span class="o">-</span> <span class="n">lat</span><span class="p">))</span>
            <span class="n">lon_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">grid_lons</span> <span class="o">-</span> <span class="n">lon</span><span class="p">))</span>
            
            
            <span class="c1">#: TODO review indexing [:,:] style vs. extract method vs. lazy data</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">grid_lats</span><span class="p">[</span><span class="n">lat_idx</span><span class="p">],</span>
                               <span class="n">longitude</span><span class="o">=</span><span class="n">grid_lons</span><span class="p">[</span><span class="n">lon_idx</span><span class="p">])</span>
            
            <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            
            <span class="n">vals</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
            <span class="c1">#sub = self.grid[:, lat_idx, lon_idx]</span>
            <span class="c1"># first slice, then access data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;latitude&#39;</span>   <span class="p">:</span>   <span class="n">lat</span><span class="p">,</span>
                           <span class="s1">&#39;longitude&#39;</span>  <span class="p">:</span>   <span class="n">lon</span><span class="p">,</span>
                           <span class="s1">&#39;name&#39;</span>       <span class="p">:</span>   <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
                            <span class="n">var</span>         <span class="p">:</span>   <span class="n">data</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">result</span></div>

                
<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">pyaerocom</span> <span class="k">as</span> <span class="nn">pya</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
    
    <span class="n">r</span> <span class="o">=</span> <span class="n">pya</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadGridded</span><span class="p">(</span><span class="s1">&#39;SPRINTARS-T213_AP3-CTRL2016-PD&#39;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">read_var</span><span class="p">(</span><span class="s1">&#39;ec550aer&#39;</span><span class="p">)</span>
    <span class="n">RUN_OLD_STUFF</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">reader</span> <span class="o">=</span> <span class="n">pya</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadGridded</span><span class="p">(</span><span class="s1">&#39;ECMWF_CAMS_REAN&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_var</span><span class="p">(</span><span class="s1">&#39;od550aer&#39;</span><span class="p">,</span> <span class="mi">2010</span><span class="p">)</span>
    
    <span class="n">t1</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_time_series</span><span class="p">(</span><span class="n">longitude</span><span class="o">=</span><span class="p">[</span><span class="mi">30</span><span class="p">],</span> <span class="n">latitude</span><span class="o">=</span><span class="p">[</span><span class="mi">40</span><span class="p">])</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_time_series_single_coord</span><span class="p">(</span><span class="n">longitude</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">latitude</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">RUN_OLD_STUFF</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io.testfiles</span> <span class="k">import</span> <span class="n">get</span>
        <span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="k">import</span> <span class="n">figure</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">get</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;models&#39;</span><span class="p">][</span><span class="s1">&#39;aatsr_su_v4.3&#39;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;od550aer&quot;</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aatsr_su_v4.3&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">data</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">tstamps</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">tstamps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tstamps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">circular</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">cropped</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">lon_range</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span> <span class="n">lat_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cropped</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cropped</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">()</span>
        
        <span class="n">other</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;models&quot;</span><span class="p">][</span><span class="s2">&quot;ecmwf_osuite&quot;</span><span class="p">],</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;od550aer&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ECMWF_OSUITE&quot;</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">()</span>
        <span class="c1">#crop randomly</span>
        <span class="n">ocropped</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">lon_range</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span> <span class="n">lat_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
        <span class="n">ocropped</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">()</span>
        <span class="c1"># some plot options</span>
        <span class="n">ocropped</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">(</span><span class="n">fix_aspect</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=.</span><span class="mi">4</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
        <span class="n">ocropped</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">c_over</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        
        <span class="c1"># crop india</span>
        <span class="n">cropped_india</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="s2">&quot;INDIA&quot;</span><span class="p">)[:</span><span class="mi">60</span><span class="p">]</span>
        <span class="n">cropped_india</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">(</span><span class="n">time_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cropped_india</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        
        <span class="n">mean</span> <span class="o">=</span> <span class="n">cropped_india</span><span class="o">.</span><span class="n">area_weighted_mean</span><span class="p">()</span>
        
        <span class="n">s</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cropped_india</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">())</span>
        
        <span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">GriddedData</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;models&quot;</span><span class="p">][</span><span class="s2">&quot;ecmwf_osuite&quot;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        
<span class="c1"># =============================================================================</span>
<span class="c1">#     import doctest</span>
<span class="c1">#     doctest.testmod()</span>
<span class="c1"># </span>
<span class="c1"># =============================================================================</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, met.no.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>