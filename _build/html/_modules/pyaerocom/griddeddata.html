

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyaerocom.griddeddata &mdash; pyaerocom  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> pyaerocom
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#aerocom">AeroCom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#citation">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#website-and-code-documentation">Website and code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#requirements">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#installation-of-pyaerocom">Installation of pyaerocom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#access-to-users-database">Access to users database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#getting-started">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pyaerocom-tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyaerocom</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pyaerocom.griddeddata</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyaerocom.griddeddata</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="n">od</span>

<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">iris</span>
<span class="kn">from</span> <span class="nn">iris.analysis.cartography</span> <span class="kn">import</span> <span class="n">area_weights</span>
<span class="kn">from</span> <span class="nn">iris.analysis</span> <span class="kn">import</span> <span class="n">MEAN</span>
<span class="kn">from</span> <span class="nn">iris.exceptions</span> <span class="kn">import</span> <span class="n">UnitConversionError</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="kn">import</span> <span class="n">const</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">print_log</span>
<span class="kn">from</span> <span class="nn">pyaerocom.helpers_landsea_masks</span> <span class="kn">import</span> <span class="n">load_region_mask_iris</span>
<span class="kn">from</span> <span class="nn">pyaerocom.tstype</span> <span class="kn">import</span> <span class="n">TsType</span>
<span class="kn">from</span> <span class="nn">pyaerocom.exceptions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">CoordinateError</span><span class="p">,</span>
                                  <span class="n">DataDimensionError</span><span class="p">,</span>
                                  <span class="n">DataExtractionError</span><span class="p">,</span>
                                  <span class="n">DimensionOrderError</span><span class="p">,</span>
                                  <span class="n">ResamplingError</span><span class="p">,</span>
                                  <span class="n">TemporalResolutionError</span><span class="p">,</span>
                                  <span class="n">VariableDefinitionError</span><span class="p">,</span>
                                  <span class="n">VariableNotFoundError</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyaerocom.time_config</span> <span class="kn">import</span> <span class="n">IRIS_AGGREGATORS</span><span class="p">,</span> <span class="n">TS_TYPE_TO_NUMPY_FREQ</span>
<span class="kn">from</span> <span class="nn">pyaerocom.time_resampler</span> <span class="kn">import</span> <span class="n">TimeResampler</span>
<span class="kn">from</span> <span class="nn">pyaerocom.helpers</span> <span class="kn">import</span> <span class="p">(</span><span class="n">get_time_rng_constraint</span><span class="p">,</span>
                               <span class="n">get_lon_rng_constraint</span><span class="p">,</span>
                               <span class="n">get_lat_rng_constraint</span><span class="p">,</span>
                               <span class="n">cftime_to_datetime64</span><span class="p">,</span>
                               <span class="n">str_to_iris</span><span class="p">,</span>
                               <span class="n">to_pandas_timestamp</span><span class="p">,</span>
                               <span class="n">datetime2str</span><span class="p">,</span>
                               <span class="n">isrange</span><span class="p">,</span> <span class="n">isnumeric</span><span class="p">,</span>
                               <span class="n">delete_all_coords_cube</span><span class="p">,</span>
                               <span class="n">copy_coords_cube</span><span class="p">,</span>
                               <span class="n">make_dummy_cube_latlon</span><span class="p">,</span>
                               <span class="n">check_coord_circular</span><span class="p">,</span>
                               <span class="n">extract_latlon_dataarray</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyaerocom.mathutils</span> <span class="kn">import</span> <span class="n">closest_index</span><span class="p">,</span> <span class="n">exponent</span>
<span class="kn">from</span> <span class="nn">pyaerocom.stationdata</span> <span class="kn">import</span> <span class="n">StationData</span>
<span class="kn">from</span> <span class="nn">pyaerocom.region</span> <span class="kn">import</span> <span class="n">Region</span>
<span class="kn">from</span> <span class="nn">pyaerocom.vert_coords</span> <span class="kn">import</span> <span class="n">AltitudeAccess</span>

<div class="viewcode-block" id="GriddedData"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData">[docs]</a><span class="k">class</span> <span class="nc">GriddedData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class representing model data</span>

<span class="sd">    This class is largely based on the :class:`iris.Cube` object. However, this</span>
<span class="sd">    object comes with an expanded functionality for convenience, for instance,</span>
<span class="sd">    netCDF files can directly be loaded in the :class:`GriddedData` object,</span>
<span class="sd">    whereas :class:`iris.cube.Cube` instances are typically created using</span>
<span class="sd">    helper methods such as</span>

<span class="sd">    1. :func:`iris.load` (returns</span>
<span class="sd">    :class:`iris.cube.CubeList`, i.e. a list-like iterable object that contains</span>
<span class="sd">    instances of :class:`Cube` objects, one for each variable) or</span>

<span class="sd">    2. :func:`iris.load_cube` which directly returns a :class:`iris.cube.Cube`</span>
<span class="sd">    instance and typically requires specification of a variable constraint.</span>

<span class="sd">    The :class:`GriddedData` object represents one variable in space and time, as</span>
<span class="sd">    well as corresponding meta information. Since it is based on the https://github.com/SciTools/iris/issues/1977</span>
<span class="sd">    :class:`iris.cube.Cube` it is optimised for netCDF files that follow the</span>
<span class="sd">    CF conventions and may not work for files that do not follow this standard.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : :obj:`str:` or :obj:`Cube`</span>
<span class="sd">        data input. Can be a single .nc file or a preloaded iris Cube.</span>
<span class="sd">    var_name : :obj:`str`, optional</span>
<span class="sd">        variable name that is extracted if `input` is a file path. Irrelevant</span>
<span class="sd">        if `input` is preloaded Cube</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_grid</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_GRID_IO</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">GRID_IO</span>
    <span class="c1">#: Req. order of dimension coordinates for time-series computation</span>
    <span class="n">COORDS_ORDER_TSERIES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">]</span>
    <span class="n">_MAX_SIZE_GB</span> <span class="o">=</span> <span class="mi">64</span> <span class="c1">#maximum file size for in-memory operations</span>

    <span class="n">SUPPORTED_VERT_SCHEMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="s1">&#39;altitude&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;profile&#39;</span><span class="p">]</span>

    <span class="n">_META_ADD</span> <span class="o">=</span> <span class="n">od</span><span class="p">(</span><span class="n">from_files</span>         <span class="o">=</span> <span class="p">[],</span>
                   <span class="n">data_id</span>            <span class="o">=</span> <span class="s2">&quot;n/d&quot;</span><span class="p">,</span>
                   <span class="n">var_name_read</span>      <span class="o">=</span> <span class="s2">&quot;n/d&quot;</span><span class="p">,</span>
                   <span class="n">ts_type</span>            <span class="o">=</span> <span class="s2">&quot;n/d&quot;</span><span class="p">,</span>
                   <span class="n">regridded</span>          <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">outliers_removed</span>   <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">computed</span>           <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">concatenated</span>       <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">region</span>             <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">reader</span>             <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convert_unit_on_init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">meta</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">input</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">([])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#attribute used to store area weights (if applicable, see method</span>
        <span class="c1">#area_weights)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_altitude_access</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># list of coordinate names as returned by name() method of iris coordinate</span>
        <span class="c1"># will be filled upon access of coord_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># list of containing var_name attributes of all coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_var_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_standard_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_long_names</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">input</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_input</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_meta</span><span class="p">(</span><span class="o">**</span><span class="n">meta</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">convert_unit_on_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_unit</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of variable&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">var_name</span>

    <span class="nd">@var_name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">var_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of variable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for var_name, need str, got </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">var_name</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_name_aerocom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AeroCom variable name&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">const</span><span class="o">.</span><span class="n">VARS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">var_name</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print information about variable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span> <span class="ow">in</span> <span class="n">const</span><span class="o">.</span><span class="n">VARS</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">const</span><span class="o">.</span><span class="n">VARS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name_aerocom</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VariableDefinitionError</span><span class="p">(</span><span class="s1">&#39;No default access available for &#39;</span>
                                              <span class="s1">&#39;variable </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">const</span><span class="o">.</span><span class="n">VARS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ts_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Temporal resolution&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;ts_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n/d&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infer_ts_type</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;ts_type&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">standard_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Standard name of variable&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">standard_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">long_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Long name of variable&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">long_name</span>

    <span class="nd">@long_name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">long_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean specifying if variable unit is AeroCom default&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">VARS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">has_unit</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">suppl_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;Outdated attribute suppl_info. Please use &#39;</span>
                               <span class="s1">&#39;metadata instead&#39;</span><span class="p">)</span>
        <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span>

<div class="viewcode-block" id="GriddedData.check_unit"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_unit">[docs]</a>    <span class="k">def</span> <span class="nf">check_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if unit of data is AeroCom default and convert if not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_ok</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">VARS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Attempting unit conversion from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">convert_unit</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">VariableDefinitionError</span><span class="p">,</span> <span class="n">UnitConversionError</span><span class="p">,</span>
                <span class="ne">MemoryError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Failed to convert unit. Reason: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_revision</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Revision string from file Revision.txt in the main data directory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">:</span>
            <span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">revision_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">REVISION_FILE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">revision_file</span><span class="p">):</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">revision_file</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">in_file</span><span class="p">:</span>
                    <span class="n">revision</span> <span class="o">=</span> <span class="n">in_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">in_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">revision</span>
        <span class="k">return</span> <span class="s1">&#39;n/a&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instance of reader class from which this object was created&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io</span> <span class="kn">import</span> <span class="n">ReadGridded</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ReadGridded</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span> <span class="o">=</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ReadGridded</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="nd">@reader</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concatenated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;concatenated&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">computed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;computed&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unit of data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">units</span>

    <span class="nd">@units</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Data array (n-dimensional numpy array)</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is a pointer to the data object of the underlying iris.Cube</span>
<span class="sd">        instance and will load the data into memory. Thus, in case of large</span>
<span class="sd">        datasets, this may lead to a memory error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot set data array: need numpy.ndarray&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Cannot assign dataarray: shape mismatch. &#39;</span>
                                     <span class="s1">&#39;Got: </span><span class="si">{}</span><span class="s1">, Need: </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">array</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">altitude_access</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_altitude_access</span><span class="p">,</span> <span class="n">AltitudeAccess</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_altitude_access</span> <span class="o">=</span> <span class="n">AltitudeAccess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_altitude_access</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array containing timedelta values for each time stamp&quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Need at least 2 timestamps in GriddedData in &#39;</span>
                                 <span class="s1">&#39;order to compute delta-t&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<div class="viewcode-block" id="GriddedData.check_frequency"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_frequency">[docs]</a>    <span class="k">def</span> <span class="nf">check_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if all datapoints are sampled at the same time frequency&quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Irregular time-frequency&#39;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">TS_TYPE_TO_NUMPY_FREQ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">freq</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Mismatch between sampling freq and &#39;</span>
                                 <span class="s1">&#39;actual frequency of values in time dimension &#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.infer_ts_type"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.infer_ts_type">[docs]</a>    <span class="k">def</span> <span class="nf">infer_ts_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to infer sampling frequency from time dimension data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            ts_type that was inferred (is assigned to metadata too)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        DataDimensionError</span>
<span class="sd">            if data object does not contain a time dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_time_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Cannot infer frequency. Data has no time &#39;</span>
                                     <span class="s1">&#39;dimension&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not identify unique frequency&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ts_type</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">TS_TYPE_TO_NUMPY_FREQ</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;ts_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts_type</span>
                <span class="k">return</span> <span class="n">ts_type</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Failed to infer ts_type from data&#39;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">TS_TYPES</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List with valid filename encryptions specifying temporal resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_opts</span><span class="o">.</span><span class="n">GRID_IO</span><span class="o">.</span><span class="n">TS_TYPES</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">from_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of file paths from which this data object was created&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;from_files&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flag specifying whether data is masked or not</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method only works if the data is loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Information cannot be accessed. Data is not &quot;</span>
                                 <span class="s2">&quot;available in memory (lazy loading)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_year</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base year of time dimension</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Changing this attribute will update the time-dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_time_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Could not access base year: data has no &#39;</span>
                                     <span class="s1">&#39;time dimension&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">utime</span><span class="p">()</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">year</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Could access base-year. Unexpected error: &#39;</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>

    <span class="nd">@base_year</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">base_year</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">change_base_year</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

<span class="c1"># =============================================================================</span>
<span class="c1">#     def change_base_year_OLD(self, new_year):</span>
<span class="c1">#         &quot;&quot;&quot;Changes base year of time dimension</span>
<span class="c1">#</span>
<span class="c1">#         Relevant, e.g. for climatological analyses</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         -----------</span>
<span class="c1">#         new_year : int</span>
<span class="c1">#             new base year (can also be other than integer if it is convertible)</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if not self.has_time_dim:</span>
<span class="c1">#             raise DataDimensionError(&#39;Data object has no time dimension ... &#39;)</span>
<span class="c1">#         if isinstance(new_year, str):</span>
<span class="c1">#             try:</span>
<span class="c1">#                 new_year = int(new_year)</span>
<span class="c1">#                 if not new_year &gt; -2000 and new_year &lt; 20000:</span>
<span class="c1">#                     raise ValueError(&#39;Need value between -2000 and 20000&#39;)</span>
<span class="c1">#             except Exception as e:</span>
<span class="c1">#                 raise ValueError(repr(e))</span>
<span class="c1">#         from cf_units import Unit</span>
<span class="c1">#         startyr = int(str(self.start.astype(&#39;datetime64[Y]&#39;)))</span>
<span class="c1">#         diff = new_year - startyr</span>
<span class="c1">#         u = self.time.units</span>
<span class="c1">#         origin = u.utime().origin.year</span>
<span class="c1">#         origin_new = u.utime().origin.year + diff</span>
<span class="c1">#         self.time.units = Unit(u.origin.replace(str(origin),</span>
<span class="c1">#                                                 str(origin_new)),</span>
<span class="c1">#                                 calendar=u.calendar)</span>
<span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="GriddedData.change_base_year"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.change_base_year">[docs]</a>    <span class="k">def</span> <span class="nf">change_base_year</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_year</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes base year of time dimension</span>

<span class="sd">        Relevant, e.g. for climatological analyses.</span>

<span class="sd">        ToDo</span>
<span class="sd">        ----</span>
<span class="sd">        Account for leap years.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method does not account for offsets arising from leap years (</span>
<span class="sd">        affecting daily or higher resolution data).</span>
<span class="sd">        It is thus recommended to use this method with care. E.g. if you use</span>
<span class="sd">        this method on a 2016 daily data object, containing a calendar that</span>
<span class="sd">        supports leap years, you&#39;ll end up with 366 time stamps also in the new</span>
<span class="sd">        data object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        new_year : int</span>
<span class="sd">            new base year (can also be other than integer if it is convertible)</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            if True, modify this object, else, use a copy</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            modified data object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io.iris_io</span> <span class="kn">import</span> <span class="n">correct_time_coord</span>
        <span class="n">data</span><span class="o">.</span><span class="n">cube</span> <span class="o">=</span> <span class="n">correct_time_coord</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cube</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ts_type</span><span class="p">,</span> <span class="n">new_year</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start time of dataset as datetime64 object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_time_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GriddedData has no time dimension&#39;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#try:</span>
        <span class="c1"># ToDo: check if this is needed</span>
        <span class="n">np_freq</span> <span class="o">=</span> <span class="n">TsType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy_freq</span><span class="p">()</span> <span class="c1">#TS_TYPE_TO_NUMPY_FREQ[self.ts_type]</span>
        <span class="n">dtype_appr</span> <span class="o">=</span> <span class="s1">&#39;datetime64[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np_freq</span><span class="p">)</span>
        <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_appr</span><span class="p">)</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#         except Exception:</span>
<span class="c1">#             logger.exception(&#39;Failed to round start time {} to beginning of &#39;</span>
<span class="c1">#                              &#39;frequency {}&#39;.format(t, self.ts_type))</span>
<span class="c1"># =============================================================================</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[us]&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start time of dataset as datetime64 object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_time_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GriddedData has no time dimension&#39;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">np_freq</span> <span class="o">=</span> <span class="n">TsType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy_freq</span><span class="p">()</span> <span class="c1">#TS_TYPE_TO_NUMPY_FREQ[self.ts_type]</span>
        <span class="n">dtype_appr</span> <span class="o">=</span> <span class="s1">&#39;datetime64[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np_freq</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_appr</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np_freq</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[us]&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;us&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cube</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instance of underlying cube object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>

    <span class="nd">@cube</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instance of underlying cube object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Underlying grid data object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span>

    <span class="nd">@grid</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Grid data format </span><span class="si">%s</span><span class="s2"> is not supported, need Cube&quot;</span>
                            <span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_META_ADD</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
                <span class="n">value</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plot_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`Variable` instance that contains plot settings</span>

<span class="sd">        The settings can be specified in the variables.ini file based on the</span>
<span class="sd">        unique var_name, see e.g. `here &lt;http://aerocom.met.no/pyaerocom/</span>
<span class="sd">        config_files.html#variables&gt;`__</span>

<span class="sd">        If no default settings can be found for this variable, all parameters</span>
<span class="sd">        will be initiated with ``None``, in which case the Aerocom plot method</span>
<span class="sd">        uses</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">const</span><span class="o">.</span><span class="n">VARS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ID of model to which data belongs&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Deprecated attribute name, please use data_id instead&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;data_id&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ID of data object (e.g. model run ID, obsnetwork ID)</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This attribute was formerly named ``name`` which is alse the</span>
<span class="sd">        corresponding attribute name in :attr:`metadata`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;data_id&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;N/D&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_climatology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s1">&#39;9999&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">ff</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if sum of shape of underlying Cube instance is &gt; 0, else False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lon_res</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Data does not contain longitude information&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Check longitudes&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lat_res</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Data does not contain longitude information&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Check latitudes&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No data available...&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array containing the order of coordinates&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coord_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List containing coordinate names&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_coord_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimcoord_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List containing coordinate names&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Area weights of lat / lon grid&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_area_weights</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span>

    <span class="nd">@area_weights</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">area_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Area weights cannot be set manually yet...&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_latlon_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean specifying whether data has latitude and longitude dimensions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;longitude&#39;</span><span class="p">]])</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_time_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean specifying whether data has latitude and longitude dimensions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span>

    <span class="k">def</span> <span class="nf">_read_netcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">perform_fmt_checks</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io.iris_io</span> <span class="kn">import</span> <span class="n">load_cube_custom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">load_cube_custom</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span>
                                     <span class="n">perform_fmt_checks</span><span class="o">=</span><span class="n">perform_fmt_checks</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;from_files&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;from_files&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;from_files&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;from_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;from_files&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;from_files&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyaerocom.io.helpers</span> <span class="kn">import</span> <span class="n">get_metadata_from_filename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_meta</span><span class="p">(</span><span class="o">**</span><span class="n">get_metadata_from_filename</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Failed to access metadata from filename&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="GriddedData.load_input"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.load_input">[docs]</a>    <span class="k">def</span> <span class="nf">load_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perform_fmt_checks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Import input as cube</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input : :obj:`str:` or :obj:`Cube`</span>
<span class="sd">            data input. Can be a single .nc file or a preloaded iris Cube.</span>
<span class="sd">        var_name : :obj:`str`, optional</span>
<span class="sd">            variable name that is extracted if `input` is a file path . Irrelevant</span>
<span class="sd">            if `input` is preloaded Cube</span>
<span class="sd">        perform_fmt_checks : bool, optional</span>
<span class="sd">            perform formatting checks based on information in filenames. Only</span>
<span class="sd">            relevant if input is a file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="nb">input</span> <span class="c1">#instance of Cube</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">input</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_netcdf</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">perform_fmt_checks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_netcdf</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">perform_fmt_checks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Failed to load input: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">var_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span> <span class="o">!=</span> <span class="n">var_name</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span> <span class="o">=</span> <span class="n">var_name</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not update var_name, invalid input &#39;</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> (need str)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_name</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_info_from_filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try access AeroCom meta info from filenames assigned to this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io</span> <span class="kn">import</span> <span class="n">FileConventionRead</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">FileConventionRead</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get_info_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">add_info</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<div class="viewcode-block" id="GriddedData.convert_unit"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.convert_unit">[docs]</a>    <span class="k">def</span> <span class="nf">convert_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert unit of data to new unit&quot;&quot;&quot;</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#         if self._size_GB &gt; self._MAX_SIZE_GB:</span>
<span class="c1">#             raise MemoryError(&#39;Cannot convert unit in {} since data is too &#39;</span>
<span class="c1">#                               &#39;large ({} GB)&#39;.format(self.name, self._size_GB))</span>
<span class="c1"># =============================================================================</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">new_unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.time_stamps"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.time_stamps">[docs]</a>    <span class="k">def</span> <span class="nf">time_stamps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert time stamps into list of numpy datetime64 objects</span>

<span class="sd">        The conversion is done using method :func:`cfunit_to_datetime64`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list containing all time stamps as datetime64 objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_time_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.years_avail"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.years_avail">[docs]</a>    <span class="k">def</span> <span class="nf">years_avail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate list of years that are available in this dataset</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toyear</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[Y]&#39;</span><span class="p">)))</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">toyear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()))]</span></div>

<div class="viewcode-block" id="GriddedData.split_years"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.split_years">[docs]</a>    <span class="k">def</span> <span class="nf">split_years</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">years</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator to split data object into individual years</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is a generator method and thus should be looped over</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        years : list, optional</span>
<span class="sd">            List of years that should be excluded. If None, it uses output</span>
<span class="sd">            from :func:`years_avail`.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            single year data object</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pyaerocom.helpers</span> <span class="kn">import</span> <span class="n">start_stop_from_year</span>
        <span class="k">if</span> <span class="n">years</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">years</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">years_avail</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">years</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Nothing to split... GriddedData contains &#39;</span>
                                 <span class="s1">&#39;only </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">years</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">start_stop_from_year</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span></div>

<div class="viewcode-block" id="GriddedData.check_coord_order"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_coord_order">[docs]</a>    <span class="k">def</span> <span class="nf">check_coord_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrapper for :func:`check_dimcoords_tseries`&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;Method was renamed, please use &#39;</span>
                                          <span class="s1">&#39;check_dimcoords_tseries&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.check_dimcoords_tseries"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_dimcoords_tseries">[docs]</a>    <span class="k">def</span> <span class="nf">check_dimcoords_tseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check order of dimension coordinates for time series retrieval</span>

<span class="sd">        For computation of time series at certain lon / lat coordinates, the</span>
<span class="sd">        data dimensions have to be in a certain order specified by</span>
<span class="sd">        :attr:`COORDS_ORDER_TSERIES`.</span>

<span class="sd">        This method checks the current order (and dimensionality) of data and</span>
<span class="sd">        raises appropriate errors.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        DataDimensionError</span>
<span class="sd">            if dimension of data is not supported (currently, 3D or 4D data</span>
<span class="sd">            is supported)</span>
<span class="sd">        DimensionOrderError</span>
<span class="sd">            if dimensions are not in the right order (in which case</span>
<span class="sd">            :func:`reorder_dimensions_tseries` may be used to catch the</span>
<span class="sd">            Exception)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Time series extraction requires at least 3 &#39;</span>
                            <span class="s1">&#39;coordinates in cube&#39;</span><span class="p">)</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#         elif not len(self.cube.dim_coords) == self.ndim:</span>
<span class="c1">#             raise DataDimensionError(&#39;Number of dimensions ({}) does not equal &#39;</span>
<span class="c1">#                                      &#39;number of dimension coordinates ({})&#39;</span>
<span class="c1">#                                      .format(self.ndim,</span>
<span class="c1">#                                              len(self.cube.dim_coords)))</span>
<span class="c1"># =============================================================================</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COORDS_ORDER_TSERIES</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Coord </span><span class="si">{}</span><span class="s1"> is not associated with a &#39;</span>
                                         <span class="s1">&#39;data dimension in cube&#39;</span>
                                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Coord </span><span class="si">{}</span><span class="s1"> is associated with &#39;</span>
                                          <span class="s1">&#39;multiple dimensions. This cannot &#39;</span>
                                          <span class="s1">&#39;yet be handled...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DimensionOrderError</span><span class="p">(</span><span class="s1">&#39;Invalid order of grid dimensions&#39;</span><span class="p">)</span></div>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#         check = self.dimcoord_names</span>
<span class="c1">#         if not len(check) &gt;= 3:</span>
<span class="c1">#             raise DataDimensionError(&#39;One of the data dimension coordinates &#39;</span>
<span class="c1">#                                      &#39;may not be defined&#39;)</span>
<span class="c1">#</span>
<span class="c1">#         for i, item in enumerate(check[:3]):</span>
<span class="c1">#             if not item == order[i]:</span>
<span class="c1">#                 raise DimensionOrderError(&#39;Invalid order of grid &#39;</span>
<span class="c1">#                                           &#39;dimension, need {}, got {}&#39;</span>
<span class="c1">#                                           .format(order,</span>
<span class="c1">#                                                   check))</span>
<span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="GriddedData.reorder_dimensions_tseries"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.reorder_dimensions_tseries">[docs]</a>    <span class="k">def</span> <span class="nf">reorder_dimensions_tseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorders dimensions of data such that :func:`to_time_series` works</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COORDS_ORDER_TSERIES</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#coord_names = [c.name() for c in self.grid.dim_coords]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Coord </span><span class="si">{}</span><span class="s1"> is not associated with a &#39;</span>
                                         <span class="s1">&#39;data dimension in cube&#39;</span>
                                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Coord </span><span class="si">{}</span><span class="s1"> is associated with &#39;</span>
                                          <span class="s1">&#39;multiple dimensions. This cannot &#39;</span>
                                          <span class="s1">&#39;yet be handled...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="n">new_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_order</span><span class="p">:</span>
                    <span class="n">new_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.reorder_dimensions_tseries_old"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.reorder_dimensions_tseries_old">[docs]</a>    <span class="k">def</span> <span class="nf">reorder_dimensions_tseries_old</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorders dimensions of data such that :func:`to_time_series` works</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COORDS_ORDER_TSERIES</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">new_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_order</span><span class="p">:</span>
                    <span class="n">new_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.transpose"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Re-order data dimensions in object</span>

<span class="sd">        Wrapper for :func:`iris.cube.Cube.transpose`</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Changes THIS object (i.e. no new instance of :class:`GriddedData` will</span>
<span class="sd">        be created)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : list</span>
<span class="sd">            new index order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.mean_at_coords"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.mean_at_coords">[docs]</a>    <span class="k">def</span> <span class="nf">mean_at_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">time_resample_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute mean value at all input locations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latitude : 1D list or similar</span>
<span class="sd">            list of latitude coordinates of coordinate locations. If None,</span>
<span class="sd">            please provided coords in iris style as list of (lat, lon) tuples</span>
<span class="sd">            via `coords` (handled via arg kwargs)</span>
<span class="sd">        longitude : 1D list or similar</span>
<span class="sd">            list of longitude coordinates of coordinate locations. If None,</span>
<span class="sd">            please provided coords in iris style as list of (lat, lon) tuples</span>
<span class="sd">            via `coords` (handled via arg kwargs)</span>
<span class="sd">        time_resample_kwargs : dict, optional</span>
<span class="sd">            time resampling arguments passed to</span>
<span class="sd">            :func:`StationData.resample_time`</span>
<span class="sd">        **kwargs</span>
<span class="sd">            additional keyword args passed to :func:`to_time_series`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            mean value at coordinates over all times available in this object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_time_series</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span>
                                 <span class="n">longitude</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">=</span>  <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_resample_kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">stat</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span>
                                   <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">time_resample_kwargs</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">mean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_coords_to_iris_sample_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">coords</span><span class="p">):</span>

        <span class="n">sample_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">cname</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                <span class="n">vals</span><span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All coord arrays need to have same length&#39;</span><span class="p">)</span>
            <span class="n">sample_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cname</span><span class="p">,</span> <span class="n">vals</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sample_points</span>

    <span class="k">def</span> <span class="nf">_iris_sample_points_to_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">):</span>
        <span class="n">lats</span><span class="p">,</span> <span class="n">lons</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sample_points</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">):</span>
                <span class="n">lats</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">):</span>
                <span class="n">lons</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lats</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">lons</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not extract latitude or longitude info &#39;</span>
                             <span class="s1">&#39;from sampling_points or both input arrays &#39;</span>
                             <span class="s1">&#39;do not have the same lenght&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">lats</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lons</span><span class="p">)</span>

<div class="viewcode-block" id="GriddedData.to_time_series"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.to_time_series">[docs]</a>    <span class="k">def</span> <span class="nf">to_time_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                       <span class="n">vert_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_iris</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">coords</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Extract time-series for provided input coordinates (lon, lat)</span>

<span class="sd">        Extract time series for each lon / lat coordinate in this cube or at</span>
<span class="sd">        predefined sample points (e.g. station data). If sample points are</span>
<span class="sd">        provided, the cube is interpolated first onto the sample points.</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Check Memory error handle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            coordinates (e.g. lon / lat) at which time series is supposed to be</span>
<span class="sd">            retrieved</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme (for details, see :func:`interpolate`)</span>
<span class="sd">        vert_scheme : str</span>
<span class="sd">            string specifying how to treat vertical coordinates. This is only</span>
<span class="sd">            relevant for data that contains vertical levels. It will be ignored</span>
<span class="sd">            otherwise. Note that if the input coordinate specifications contain</span>
<span class="sd">            altitude information, this parameter will be set automatically to</span>
<span class="sd">            &#39;altitude&#39;. Allowed inputs are all data collapse schemes that</span>
<span class="sd">            are supported by :func:`pyaerocom.helpers.str_to_iris` (e.g. `mean,</span>
<span class="sd">            median, sum`). Further valid schemes are `altitude, surface,</span>
<span class="sd">            profile`.</span>
<span class="sd">            If not other specified and if `altitude` coordinates are provided</span>
<span class="sd">            via sample_points (or **coords parameters) then, vert_scheme will</span>
<span class="sd">            be set to `altitude`. Else, `profile` is used.</span>
<span class="sd">        add_meta : dict, optional</span>
<span class="sd">            dictionary specifying additional metadata for individual input</span>
<span class="sd">            coordinates. Keys are meta attribute names (e.g. station_name)</span>
<span class="sd">            and corresponding values are lists (with length of input coords)</span>
<span class="sd">            or single entries that are supposed to be assigned to each station.</span>
<span class="sd">            E.g. `add_meta=dict(station_name=[&lt;list_of_station_names&gt;])`).</span>
<span class="sd">        **coords</span>
<span class="sd">            additional keyword args that may be used to provide the interpolation</span>
<span class="sd">            coordinates (for details, see :func:`interpolate`)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of result dictionaries for each coordinate. Dictionary keys</span>
<span class="sd">            are: ``longitude, latitude, var_name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;collapse_scalar&#39;</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span> <span class="c1">#for backwards compatibility</span>
            <span class="n">collapse_scalar</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;collapse_scalar&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collapse_scalar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>
        <span class="n">pinfo</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5913000</span><span class="p">:</span> <span class="c1"># (shape of 2x2 deg, daily data)</span>
            <span class="n">pinfo</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Extracting timeseries data from large array &#39;</span>
                                 <span class="s1">&#39;(shape: </span><span class="si">{}</span><span class="s1">). This may take a while...&#39;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="c1"># if the method makes it to this point, it is 3 or 4 dimensional</span>
        <span class="c1"># and the first 3 dimensions are time, latitude, longitude.</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#         lens = [len(x[1]) for x in sample_points]</span>
<span class="c1">#         if not all([lens[0]==x for x in lens]):</span>
<span class="c1">#             raise ValueError(&quot;Arrays for sample coordinates must have the &quot;</span>
<span class="c1">#                              &quot;same lengths&quot;)</span>
<span class="c1"># =============================================================================</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1">#data does not contain vertical dimension</span>
            <span class="k">if</span> <span class="n">use_iris</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sample_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sample_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords_to_iris_sample_points</span><span class="p">(</span><span class="o">**</span><span class="n">coords</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_timeseries_2D</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span>
                                                <span class="n">collapse_scalar</span><span class="o">=</span><span class="n">collapse_scalar</span><span class="p">,</span>
                                                <span class="n">add_meta</span><span class="o">=</span><span class="n">add_meta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">coords</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iris_sample_points_to_coords</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_time_series_xarray</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span>
                                                     <span class="n">add_meta</span><span class="o">=</span><span class="n">add_meta</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pinfo</span><span class="p">:</span>
                <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Time series extraction successful. &#39;</span>
                                     <span class="s1">&#39;Elapsed time: </span><span class="si">{:.0f}</span><span class="s1"> s&#39;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">sample_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords_to_iris_sample_points</span><span class="p">(</span><span class="o">**</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_timeseries_3D</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span>
                                      <span class="n">collapse_scalar</span><span class="o">=</span><span class="n">collapse_scalar</span><span class="p">,</span>
                                      <span class="n">vert_scheme</span><span class="o">=</span><span class="n">vert_scheme</span><span class="p">,</span>
                                      <span class="n">add_meta</span><span class="o">=</span><span class="n">add_meta</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_to_time_series_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                               <span class="n">add_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">coords</span><span class="p">):</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Please provide only latitude / longitude &#39;</span>
                                      <span class="s1">&#39;sampling points as input&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span>
                <span class="n">lat</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">elif</span> <span class="n">coord</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span>
                <span class="n">lon</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="k">if</span> <span class="n">lat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide latitude and longitude coords&#39;</span><span class="p">)</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">extract_latlon_dataarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span>
                                          <span class="n">new_index_name</span><span class="o">=</span><span class="s1">&#39;latlon&#39;</span><span class="p">)</span>

        <span class="n">lat_id</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;lat_dimname&#39;</span><span class="p">]</span>
        <span class="n">lon_id</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;lon_dimname&#39;</span><span class="p">]</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>

        <span class="n">meta_iter</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">meta_glob</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">add_meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_val</span> <span class="ow">in</span> <span class="n">add_meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta_val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span>
                    <span class="n">meta_iter</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">meta_glob</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">data_np</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">data</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">lat_id</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">lon_id</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">sidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">StationData</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lats</span><span class="p">[</span><span class="n">sidx</span><span class="p">],</span>
                               <span class="n">longitude</span><span class="o">=</span><span class="n">lons</span><span class="p">[</span><span class="n">sidx</span><span class="p">],</span>
                               <span class="n">data_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                               <span class="n">ts_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">var_info</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">}</span>

            <span class="n">vals</span> <span class="o">=</span> <span class="n">data_np</span><span class="p">[:,</span> <span class="n">sidx</span><span class="p">]</span>

            <span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_val</span> <span class="ow">in</span> <span class="n">meta_iter</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span><span class="p">[</span><span class="n">sidx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_val</span> <span class="ow">in</span> <span class="n">meta_glob</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span>

            <span class="k">if</span> <span class="n">ts_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">ts_type</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_to_timeseries_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="p">,</span>
                          <span class="n">add_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract time-series for provided input coordinates (lon, lat)</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Check Memory error handle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            coordinates (e.g. lon / lat) at which time series is supposed to be</span>
<span class="sd">            retrieved</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme (for details, see :func:`interpolate`)</span>
<span class="sd">        collapse_scalar : bool</span>
<span class="sd">            see :func:`interpolate`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of result dictionaries for each coordinate. Dictionary keys</span>
<span class="sd">            are: ``longitude, latitude, var_name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Developers: Debug! Users: please contact &#39;</span>
                            <span class="s1">&#39;developers :)&#39;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>

        <span class="c1">#lats, lons = tuple_list_to_lists(sample_points)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_points</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;latitude&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_points</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;longitude&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="n">grid_lons</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">meta_iter</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">meta_glob</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">add_meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_val</span> <span class="ow">in</span> <span class="n">add_meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta_val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span>
                    <span class="n">meta_iter</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">meta_glob</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lats</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">grid_lons</span><span class="o">==</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">StationData</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span>
                               <span class="n">longitude</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span>
                               <span class="n">data_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                               <span class="n">ts_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">var_info</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">}</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

            <span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_val</span> <span class="ow">in</span> <span class="n">meta_iter</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_val</span> <span class="ow">in</span> <span class="n">meta_glob</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_val</span>

            <span class="k">if</span> <span class="n">ts_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">ts_type</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_to_timeseries_3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="p">,</span>
                          <span class="n">vert_scheme</span><span class="o">=</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="n">add_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Data contains vertical dimension</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_vert_scheme</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">vert_scheme</span><span class="p">)</span>

        <span class="c1"># ToDo: check if _to_timeseries_2D can be called here</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to_time_series</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span>
                                   <span class="n">collapse_scalar</span><span class="p">,</span> <span class="n">add_meta</span><span class="o">=</span><span class="n">add_meta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_vert_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">vert_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method that checks and infers vertical scheme for time</span>
<span class="sd">        series computation from 3D data (used in :func:`_to_timeseries_3D`)&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">vert_scheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Setting vert_scheme in GriddedData to mean&#39;</span><span class="p">)</span>
            <span class="n">vert_scheme</span> <span class="o">=</span><span class="s1">&#39;mean&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>

        <span class="n">cname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vert_scheme</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_VERT_SCHEMES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for vert_scheme: </span><span class="si">{}</span><span class="s1">. Supported &#39;</span>
                             <span class="s1">&#39;schemes are: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vert_scheme</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_VERT_SCHEMES</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">vert_scheme</span> <span class="o">==</span> <span class="s1">&#39;surface&#39;</span><span class="p">:</span>
            <span class="n">vert_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_index_surface_level</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[:,:,:,</span><span class="n">vert_index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">vert_scheme</span> <span class="o">==</span> <span class="s1">&#39;altitude&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;altitude&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">sample_points</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Require altitude specification in sample &#39;</span>
                                 <span class="s1">&#39;points for vert_scheme altitude&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_altitude_access</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Cannot access altitude &#39;</span>
                                         <span class="s1">&#39;information&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot yet retrieve timeseries at &#39;</span>
                                      <span class="s1">&#39;altitude levels. Coming soon...&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">vert_scheme</span> <span class="o">==</span> <span class="s1">&#39;profile&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot yet retrieve profile timeseries&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># check if vertical scheme can be converted into valid iris</span>
                <span class="c1"># aggregator (in which case vertical dimension is collapsed)</span>
                <span class="n">aggr</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">vert_scheme</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">cname</span><span class="p">,</span> <span class="n">aggr</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot yet retrieve timeseries &#39;</span>
                                  <span class="s1">&#39;from 4D data for vert_scheme </span><span class="si">{}</span><span class="s1"> &#39;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vert_scheme</span><span class="p">))</span>

<div class="viewcode-block" id="GriddedData.check_altitude_access"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_altitude_access">[docs]</a>    <span class="k">def</span> <span class="nf">check_altitude_access</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if altitude levels can be accessed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True, if altitude access is provided, else False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude_access</span><span class="o">.</span><span class="n">check_altitude_access</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.get_altitude"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.get_altitude">[docs]</a>    <span class="k">def</span> <span class="nf">get_altitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract (or try to compute) altitude values at input coordinates&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_altitude_access</span><span class="p">,</span> <span class="n">AltitudeAccess</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_altitude_access</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_altitude_access</span><span class="o">.</span><span class="n">get_altitude</span><span class="p">(</span><span class="o">**</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Coming soon...&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.extract_surface_level"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.extract_surface_level">[docs]</a>    <span class="k">def</span> <span class="nf">extract_surface_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract surface level from 4D field&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Can only extract surface level for 4D &#39;</span>
                                     <span class="s1">&#39;gridded data object&#39;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_index_surface_level</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:,:,:,</span><span class="n">idx</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_infer_index_surface_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Can only infer surface level for 4D &#39;</span>
                                     <span class="s1">&#39;gridded data object&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>
        <span class="n">cname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span>
        <span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="kn">import</span> <span class="n">vert_coords</span> <span class="k">as</span> <span class="n">vc</span>
        <span class="k">if</span> <span class="s1">&#39;positive&#39;</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">VerticalCoordinate</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">lev_increases_with_alt</span><span class="p">:</span>
                <span class="c1"># vertical coordinate values increase with altitude -&gt; find lowest value (e.g. altitude)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># vertical coordinate values decrease with altitude -&gt; find highest value (e.g. pressure)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">const</span><span class="o">.</span><span class="n">GRID_IO</span><span class="o">.</span><span class="n">INFER_SURFACE_LEVEL</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s1">&#39;Cannot infer surface level since &#39;</span>
                                          <span class="s1">&#39;global option INFER_SURFACE_LEVEL in&#39;</span>
                                          <span class="s1">&#39;pyaerocom.const.GRID_IO is deactivated&#39;</span><span class="p">)</span>
            <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;Inferring surface level in GriddedData based on mean value of &#39;</span>
                <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> data in first and last level since CF coordinate info is &#39;</span>
                <span class="s1">&#39;missing... The level with the largest mean value will be &#39;</span>
                <span class="s1">&#39;assumed to be the surface. If mean values in both levels&#39;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">))</span>
            <span class="n">last_lev_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">mean_first_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">mean_last_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">last_lev_idx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exponent</span><span class="p">(</span><span class="n">mean_first_idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">exponent</span><span class="p">(</span><span class="n">mean_last_idx</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s1">&#39;Could not infer surface level. &#39;</span>
                    <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> data in first and last level is of similar magnitude...&#39;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">mean_first_idx</span> <span class="o">&gt;</span> <span class="n">mean_last_idx</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">last_lev_idx</span>

<div class="viewcode-block" id="GriddedData.to_time_series_single_coord"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.to_time_series_single_coord">[docs]</a>    <span class="k">def</span> <span class="nf">to_time_series_single_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make time series dictionary of single location using neirest coordinate</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Crop before extraction</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latitude : float</span>
<span class="sd">            latitude of coordinate</span>
<span class="sd">        longitude : float</span>
<span class="sd">            longitude of coordinate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            dictionary containing results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;This method is deprecated since &#39;</span>
                                           <span class="s1">&#39;version 0.8.0&#39;</span><span class="p">))</span></div>
<span class="c1"># =============================================================================</span>
<span class="c1">#         self.check_dimcoords_tseries()</span>
<span class="c1">#         if not self.ndim == 3:</span>
<span class="c1">#             raise DataDimensionError(&#39;So far, timeseries can only be extracted &#39;</span>
<span class="c1">#                                      &#39;from 3 dimensional data...&#39;)</span>
<span class="c1">#         lons = self.longitude.points</span>
<span class="c1">#         lats = self.latitude.points</span>
<span class="c1">#         lon_idx = np.argmin(np.abs(lons - longitude))</span>
<span class="c1">#         lat_idx = np.argmin(np.abs(lats - latitude))</span>
<span class="c1">#         times = self.time_stamps()</span>
<span class="c1">#         data = self.grid.data[:, lat_idx, lon_idx]</span>
<span class="c1">#         return {&#39;latitude&#39;      : latitude,</span>
<span class="c1">#                 &#39;longitude&#39;     : longitude,</span>
<span class="c1">#                 &#39;name&#39;          : self.name,</span>
<span class="c1">#                 self.var_name   : pd.Series(data, times)}</span>
<span class="c1"># =============================================================================</span>

    <span class="k">def</span> <span class="nf">_closest_time_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find closest index to input in time dimension&quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">nearest_neighbour_index</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<div class="viewcode-block" id="GriddedData.find_closest_index"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.find_closest_index">[docs]</a>    <span class="k">def</span> <span class="nf">find_closest_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">dimcoord_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the closest indices for dimension coordinate values&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dimcoord_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;No such dimension </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closest_time_idx</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">nearest_neighbour_index</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span></div>

<div class="viewcode-block" id="GriddedData.isel"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.isel">[docs]</a>    <span class="k">def</span> <span class="nf">isel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Please use method sel for data selection &#39;</span>
                                  <span class="s1">&#39;based on dimension values&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.sel"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.sel">[docs]</a>    <span class="k">def</span> <span class="nf">sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_neirest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">dimcoord_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select subset by dimension names</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is a BETA version, please use with care</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **dimcoord_vals</span>
<span class="sd">            key / value pairs specifying coordinate values to be extracted</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            subset data object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rng_funs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;time&#39;</span>   <span class="p">:</span> <span class="n">get_time_rng_constraint</span><span class="p">,</span>
                    <span class="s1">&#39;longitude&#39;</span> <span class="p">:</span> <span class="n">get_lon_rng_constraint</span><span class="p">,</span>
                    <span class="s1">&#39;latitude&#39;</span> <span class="p">:</span> <span class="n">get_lat_rng_constraint</span><span class="p">}</span>

        <span class="n">coord_vals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dimcoord_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">is_rng</span> <span class="o">=</span> <span class="n">isrange</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_rng</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">rng_funs</span><span class="p">[</span><span class="n">dim</span><span class="p">](</span><span class="n">val</span><span class="p">)</span>
                <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                        <span class="n">_tval</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closest_time_idx</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                        <span class="n">_tval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">_cval</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">_tval</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_neirest</span> <span class="ow">and</span> <span class="n">_cval</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s1">&#39;No such value </span><span class="si">{}</span><span class="s1"> in dim </span><span class="si">{}</span><span class="s1">. &#39;</span>
                                                  <span class="s1">&#39;Use option use_neirest to &#39;</span>
                                                  <span class="s1">&#39;disregard and extract &#39;</span>
                                                  <span class="s1">&#39;neirest neighbour&#39;</span><span class="o">.</span><span class="n">format</span>
                                                  <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">nearest_neighbour_index</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">_cval</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">_idx</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_neirest</span> <span class="ow">and</span> <span class="n">_cval</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s1">&#39;No such value </span><span class="si">{}</span><span class="s1"> in dim </span><span class="si">{}</span><span class="s1">&#39;</span>
                                                  <span class="s1">&#39;Use option use_neirest to &#39;</span>
                                                  <span class="s1">&#39;disregard and extract &#39;</span>
                                                  <span class="s1">&#39;neirest neighbour&#39;</span><span class="o">.</span><span class="n">format</span>
                                                  <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
                <span class="n">coord_vals</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">_cval</span>

        <span class="k">if</span> <span class="n">coord_vals</span><span class="p">:</span>
            <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">coord_values</span><span class="o">=</span><span class="n">coord_vals</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">cadd</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">cadd</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s1">&#39;Failed to extract subset for input &#39;</span>
                                      <span class="s1">&#39;coordinates </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dimcoord_vals</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">subset</span></div>

    <span class="c1"># TODO: Test, confirm and remove beta flag in docstring</span>
<div class="viewcode-block" id="GriddedData.remove_outliers"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.remove_outliers">[docs]</a>    <span class="k">def</span> <span class="nf">remove_outliers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove outliers from data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low : float</span>
<span class="sd">            lower end of valid range for input variable. If None, then the</span>
<span class="sd">            corresponding value from the default settings for this variable</span>
<span class="sd">            are used (cf. minimum attribute of `available variables</span>
<span class="sd">            &lt;https://pyaerocom.met.no/config_files.html#variables&gt;`__)</span>
<span class="sd">        high : float</span>
<span class="sd">            upper end of valid range for input variable. If None, then the</span>
<span class="sd">            corresponding value from the default settings for this variable</span>
<span class="sd">            are used (cf. maximum attribute of `available variables</span>
<span class="sd">            &lt;https://pyaerocom.met.no/config_files.html#variables&gt;`__)</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            if True, this object is modified, else outliers are removed in</span>
<span class="sd">            a copy of this object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            modified data object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_info</span><span class="o">.</span><span class="n">minimum</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Setting </span><span class="si">{}</span><span class="s1"> outlier lower lim: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">low</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_info</span><span class="o">.</span><span class="n">maximum</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Setting </span><span class="si">{}</span><span class="s1"> outlier upper lim: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">high</span><span class="p">))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_ensure_is_masked_array</span><span class="p">()</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">data</span><span class="o">&lt;</span><span class="n">low</span><span class="p">,</span> <span class="n">data</span><span class="o">&gt;</span><span class="n">high</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;outliers_removed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">_ensure_is_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make sure underlying data is masked array</span>

<span class="sd">        Required, e.g. for removal of outliers</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Will trigger &quot;realisation&quot; of data (i.e. loading of numpy array) in</span>
<span class="sd">        case data is lazily loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_resample_time_iris</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_ts_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample time dimension using iris funcitonality</span>

<span class="sd">        This does not allow to specify further constraints but just</span>
<span class="sd">        aggregates to input resolution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_ts_type : str</span>
<span class="sd">            either of the supported temporal resolutions (cf.</span>
<span class="sd">            :attr:`IRIS_AGGREGATORS` in :mod:`helpers`, e.g. &quot;monthly&quot;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing downscaled data</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TemporalResolutionError</span>
<span class="sd">            if input resolution is not provided, or if it is higher temporal</span>
<span class="sd">            resolution than this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#from pyaerocom.tstype import TsType</span>

        <span class="n">to</span> <span class="o">=</span> <span class="n">TsType</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">TsType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">current</span> <span class="o">==</span> <span class="n">to</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data is already in </span><span class="si">{}</span><span class="s1"> resolution&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_ts_type</span> <span class="ow">in</span> <span class="n">IRIS_AGGREGATORS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TemporalResolutionError</span><span class="p">(</span><span class="s1">&#39;Resolution </span><span class="si">{}</span><span class="s1"> cannot &#39;</span>
                <span class="s1">&#39;converted&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">:</span> <span class="c1">#current resolution is smaller than desired</span>
            <span class="k">raise</span> <span class="n">TemporalResolutionError</span><span class="p">(</span><span class="s1">&#39;Cannot increase &#39;</span>
                <span class="s1">&#39;temporal resolution from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">,</span>
                                          <span class="n">to_ts_type</span><span class="p">))</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>

        <span class="c1"># Create aggregators</span>
        <span class="n">aggrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;yearly&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_ts_type</span> <span class="ow">in</span> <span class="n">aggrs</span><span class="p">:</span>
            <span class="n">aggrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">aggr</span> <span class="ow">in</span> <span class="n">aggrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">aggr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">aux_coords</span><span class="p">]:</span>
                <span class="c1"># this adds the corresponding aggregator to the cube</span>
                <span class="n">IRIS_AGGREGATORS</span><span class="p">[</span><span class="n">aggr</span><span class="p">](</span><span class="n">cube</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">aggr</span><span class="p">)</span>
            <span class="c1">#IRIS_AGGREGATORS[to_ts_type](cube, &#39;time&#39;, name=to_ts_type)</span>
        <span class="c1"># not downscale</span>
        <span class="n">aggregated</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">aggregated_by</span><span class="p">(</span><span class="n">aggrs</span><span class="p">,</span> <span class="n">MEAN</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">aggregated</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;ts_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_ts_type</span>
        <span class="n">data</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_resample_time_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_ts_type</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">apply_constraints</span><span class="p">,</span>
                              <span class="n">min_num_obs</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xarr</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="n">xarr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">from_iris</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="n">TimeResampler</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">arr_out</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">,</span> <span class="n">from_ts_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">,</span>
                                  <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                  <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_constraints</span><span class="p">,</span>
                                  <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># likely non-standard datetime objects in array (cf https://github.com/pydata/xarray/issues/3426)</span>
            <span class="n">arr</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="n">TimeResampler</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">arr_out</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">,</span>
                                  <span class="n">from_ts_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">,</span>
                                  <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                  <span class="n">apply_constraints</span><span class="o">=</span><span class="n">apply_constraints</span><span class="p">,</span>
                                  <span class="n">min_num_obs</span><span class="o">=</span><span class="n">min_num_obs</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">arr_out</span><span class="o">.</span><span class="n">to_iris</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;ts_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_ts_type</span>
        <span class="n">data</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">last_setup</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="GriddedData.resample_time"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.resample_time">[docs]</a>    <span class="k">def</span> <span class="nf">resample_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_ts_type</span><span class="o">=</span><span class="s1">&#39;monthly&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                      <span class="n">apply_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_num_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">use_iris</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample time to input resolution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_ts_type : str</span>
<span class="sd">            either of the supported temporal resolutions (cf.</span>
<span class="sd">            :attr:`IRIS_AGGREGATORS` in :mod:`helpers`, e.g. &quot;monthly&quot;)</span>
<span class="sd">        how : str</span>
<span class="sd">            string specifying how the data is to be aggregated, default is mean</span>
<span class="sd">        apply_constraints : bool, optional</span>
<span class="sd">            if True, hierarchical resampling is applied using input</span>
<span class="sd">            `min_num_obs` (if provided) or else, using constraints</span>
<span class="sd">            specified in :attr:`pyaerocom.const.OBS_MIN_NUM_RESAMPLE`</span>
<span class="sd">        min_num_obs : dict or int, optinal</span>
<span class="sd">            integer or nested dictionary specifying minimum number of</span>
<span class="sd">            observations required to resample from higher to lower frequency.</span>
<span class="sd">            For instance, if `input_data` is hourly and `to_ts_type` is</span>
<span class="sd">            monthly, you may specify something like::</span>

<span class="sd">                min_num_obs =</span>
<span class="sd">                    {&#39;monthly&#39;  :   {&#39;daily&#39;  : 7},</span>
<span class="sd">                     &#39;daily&#39;    :   {&#39;hourly&#39; : 6}}</span>

<span class="sd">            to require at least 6 hours per day and 7 days per month.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing downscaled data</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TemporalResolutionError</span>
<span class="sd">            if input resolution is not provided, or if it is higher temporal</span>
<span class="sd">            resolution than this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_time_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Require time dimension in GriddedData: &#39;</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">short_str</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">use_iris</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">apply_constraints</span> <span class="ow">and</span> <span class="n">how</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resample_time_iris</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resample_time_xarray</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span>
                                              <span class="n">apply_constraints</span><span class="p">,</span>
                                              <span class="n">min_num_obs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ResamplingError</span><span class="p">(</span><span class="s1">&#39;Resampling of time in GriddedData failed &#39;</span>
                                  <span class="s1">&#39;using xarray. Reason: </span><span class="si">{}</span><span class="s1">. Please try again &#39;</span>
                                  <span class="s1">&#39;with input arg use_iris=True&#39;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span></div>

<div class="viewcode-block" id="GriddedData.downscale_time"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.downscale_time">[docs]</a>    <span class="k">def</span> <span class="nf">downscale_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_ts_type</span><span class="o">=</span><span class="s1">&#39;monthly&#39;</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;This method is deprecated. Please use new &#39;</span>
                                 <span class="s1">&#39;name resample_time&#39;</span><span class="p">)</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="n">to_ts_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.add_aggregator"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.add_aggregator">[docs]</a>    <span class="k">def</span> <span class="nf">add_aggregator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggr_name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="GriddedData.calc_area_weights"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.calc_area_weights">[docs]</a>    <span class="k">def</span> <span class="nf">calc_area_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate area weights for grid&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_latlon_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Data does not have latitude and longitude &#39;</span>
                                     <span class="s1">&#39;dimensions. This is required for &#39;</span>
                                     <span class="s1">&#39;computation of area weights.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_lonlat_bounds</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_weights</span> <span class="o">=</span> <span class="n">area_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_weights</span></div>

<div class="viewcode-block" id="GriddedData.filter_altitude"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.filter_altitude">[docs]</a>    <span class="k">def</span> <span class="nf">filter_altitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Currently dummy method that makes life easier in :class:`Filter`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            current instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">const</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Altitude filtering is not applied in GriddedData &#39;</span>
                          <span class="s1">&#39;and will be skipped&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="GriddedData.filter_region"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.filter_region">[docs]</a>    <span class="k">def</span> <span class="nf">filter_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter region based on ID</span>

<span class="sd">        This works both for rectangular regions and mask regions</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        region_id : str</span>
<span class="sd">            name of region</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            if True, the current data object is modified, else a new object</span>
<span class="sd">            is returned</span>
<span class="sd">        **kwargs</span>
<span class="sd">            additional keyword args passed to :func:`apply_region_mask` if</span>
<span class="sd">            input region is a mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            filtered data object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">region_id</span> <span class="ow">in</span> <span class="n">const</span><span class="o">.</span><span class="n">HTAP_REGIONS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_region_mask</span><span class="p">(</span><span class="n">region_id</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="n">region_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.apply_region_mask"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.apply_region_mask">[docs]</a>    <span class="k">def</span> <span class="nf">apply_region_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">,</span> <span class="n">thresh_coast</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a masked region filter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">region_id</span> <span class="ow">in</span> <span class="n">const</span><span class="o">.</span><span class="n">HTAP_REGIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for region_id: </span><span class="si">{}</span><span class="s1">, choose from: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">region_id</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">HTAP_REGIONS</span><span class="p">))</span>

        <span class="c1"># get Iris mask</span>
        <span class="n">mask_iris</span> <span class="o">=</span> <span class="n">load_region_mask_iris</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span>

        <span class="c1"># Reads mask to griddedata</span>
        <span class="n">mask</span>  <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">mask_iris</span><span class="p">,</span> <span class="n">convert_unit_on_init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="p">)</span>

        <span class="c1">#mask.quickplot_map(vmin=0, vmax=1)</span>
        <span class="n">npm</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">npm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">npm</span> <span class="o">=</span> <span class="n">npm</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">thresh_mask</span> <span class="o">=</span> <span class="n">npm</span> <span class="o">&gt;</span> <span class="n">thresh_coast</span>
        <span class="n">npm</span><span class="p">[</span><span class="n">thresh_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">npm</span><span class="p">[</span><span class="o">~</span><span class="n">thresh_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1">#griddeddata = self.copy()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">griddeddata</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">griddeddata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># UPDATE MASK WITH REGIONAL MASK.</span>
            <span class="n">griddeddata</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">npm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">griddeddata</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">region_id</span>

        <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Coming soon... &quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">griddeddata</span></div>

<div class="viewcode-block" id="GriddedData.crop"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.crop">[docs]</a>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lat_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">time_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;High level function that applies cropping along multiple axes</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">            1. For cropping of longitudes and latitudes, the method</span>
<span class="sd">            :func:`iris.cube.Cube.intersection` is used since it automatically</span>
<span class="sd">            accepts and understands longitude input based on definition</span>
<span class="sd">            0 &lt;= lon &lt;= 360 as well as for -180 &lt;= lon &lt;= 180</span>
<span class="sd">            2. Time extraction may be provided directly as index or in form of</span>
<span class="sd">            :class:`pandas.Timestamp` objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon_range : :obj:`tuple`, optional</span>
<span class="sd">            2-element tuple containing longitude range for cropping. If None,</span>
<span class="sd">            the longitude axis remains unchanged.</span>
<span class="sd">            Example input to crop around meridian: `lon_range=(-30, 30)`</span>
<span class="sd">        lat_range : :obj:`tuple`, optional</span>
<span class="sd">            2-element tuple containing latitude range for cropping. If None,</span>
<span class="sd">            the latitude axis remains unchanged</span>
<span class="sd">        time_range : :obj:`tuple`, optional</span>
<span class="sd">            2-element tuple containing time range for cropping. Allowed data</span>
<span class="sd">            types for specifying the times are</span>

<span class="sd">                1. a combination of 2 :class:`pandas.Timestamp` instances or</span>
<span class="sd">                2. a combination of two strings that can be directly converted\</span>
<span class="sd">                into :class:`pandas.Timestamp` instances (e.g.\</span>
<span class="sd">                `time_range=(&quot;2010-1-1&quot;, &quot;2012-1-1&quot;)`) or</span>
<span class="sd">                3. directly a combination of indices (:obj:`int`).</span>

<span class="sd">            If None, the time axis remains unchanged.</span>
<span class="sd">        region : :obj:`str` or :obj:`Region`, optional</span>
<span class="sd">            string ID of pyaerocom default region or directly an instance of</span>
<span class="sd">            the :class:`Region` object. May be used instead of</span>
<span class="sd">            ``lon_range`` and ``lat_range``, if these are unspecified.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing cropped grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">suppl</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">suppl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">region</span> <span class="o">=</span> <span class="n">Region</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to access longitude / latitude range &quot;</span>
                                   <span class="s2">&quot;using region ID </span><span class="si">{}</span><span class="s2">. Error msg: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                           <span class="n">region</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">Region</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid input for region&quot;</span><span class="p">)</span>
            <span class="n">suppl</span><span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">name</span>
            <span class="n">lon_range</span><span class="p">,</span> <span class="n">lat_range</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">lon_range</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">lat_range</span>
        <span class="k">if</span> <span class="n">lon_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lat_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">longitude</span><span class="o">=</span><span class="n">lon_range</span><span class="p">,</span>
                                          <span class="n">latitude</span><span class="o">=</span><span class="n">lat_range</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lon_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lat_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">longitude</span><span class="o">=</span><span class="n">lon_range</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lon_range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lat_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lat_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s2">&quot;Failed to apply spatial cropping...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">suppl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">):</span>
                <span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                              <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cropping along time axis based on Timestamps&quot;</span><span class="p">)</span>
                <span class="n">time_constraint</span> <span class="o">=</span> <span class="n">get_time_rng_constraint</span><span class="p">(</span><span class="o">*</span><span class="n">time_range</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">time_constraint</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">time_range</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cropping along time axis based on indices&quot;</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s2">&quot;Failed to apply temporal cropping&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">suppl</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.get_area_weighted_timeseries"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.get_area_weighted_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">get_area_weighted_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method to extract area weighted mean timeseries</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region</span>
<span class="sd">            optional, name of AeroCom default region for which the mean is to</span>
<span class="sd">            be calculated (e.g. EUROPE)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        StationData</span>
<span class="sd">            station data containing area weighted mean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Area weighted mean can only computed &#39;</span>
                                      <span class="s1">&#39;for data containing latitude and &#39;</span>
                                      <span class="s1">&#39;longitude data&#39;</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="n">StationData</span><span class="p">()</span>
        <span class="n">stat</span><span class="o">.</span><span class="n">station_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_id</span>
        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">)</span>
            <span class="n">stat</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">area_weighted_mean</span><span class="p">()</span>

        <span class="n">stat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">stat</span></div>

    <span class="c1"># redefined methods from iris.Cube class. This includes all Cube</span>
    <span class="c1"># processing methods that exist in the Cube class and that work on the</span>
    <span class="c1"># Cube and return a Cube instance. These may be expanded (e.g. for</span>
    <span class="c1"># instance what they accept as input</span>
<div class="viewcode-block" id="GriddedData.aerocom_filename"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.aerocom_filename">[docs]</a>    <span class="k">def</span> <span class="nf">aerocom_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at_stations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filename of data following Aerocom 3 conventions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        at_stations : str</span>
<span class="sd">            if True, then AtStations string will be included in filename</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            generated file name based on what is in this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;This method is deprecated. Please use &#39;</span>
                               <span class="s1">&#39;aerocom_savename instead&#39;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io</span> <span class="kn">import</span> <span class="n">FileConventionRead</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fconv</span> <span class="o">=</span> <span class="n">FileConventionRead</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">base_info</span> <span class="o">=</span> <span class="n">fconv</span><span class="o">.</span><span class="n">get_info_from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">vert_code</span> <span class="o">=</span> <span class="n">base_info</span><span class="p">[</span><span class="s1">&#39;vert_code&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vert_code</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vert_code</span> <span class="o">=</span> <span class="s1">&#39;UNDEFINED&#39;</span>
        <span class="k">if</span> <span class="n">at_stations</span><span class="p">:</span>
            <span class="n">vert_code</span> <span class="o">+=</span> <span class="s1">&#39;AtStations&#39;</span>

        <span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="n">fconv</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">vert_code</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">year</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fconv</span><span class="o">.</span><span class="n">file_sep</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.nc&#39;</span></div>

<div class="viewcode-block" id="GriddedData.aerocom_savename"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.aerocom_savename">[docs]</a>    <span class="k">def</span> <span class="nf">aerocom_savename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">vert_code</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get filename for saving following AeroCom conventions&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io.helpers</span> <span class="kn">import</span> <span class="n">aerocom_savename</span>
        <span class="k">if</span> <span class="n">vert_code</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pyaerocom.io.fileconventions</span> <span class="kn">import</span> <span class="n">FileConventionRead</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">fconv</span> <span class="o">=</span> <span class="n">FileConventionRead</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">vert_code</span> <span class="o">=</span> <span class="n">fconv</span><span class="o">.</span><span class="n">get_info_from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="s1">&#39;vert_code&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">vert_code</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide input vert_code&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_id</span>
        <span class="k">if</span> <span class="n">var_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>
        <span class="k">if</span> <span class="n">year</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot create AeroCom savename for multiyear &#39;</span>
                                 <span class="s1">&#39;data... please split first&#39;</span><span class="p">)</span>
            <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ts_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ts_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span>
        <span class="k">return</span> <span class="n">aerocom_savename</span><span class="p">(</span><span class="n">data_id</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">vert_code</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">ts_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.compute_at_stations_file"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.compute_at_stations_file">[docs]</a>    <span class="k">def</span> <span class="nf">compute_at_stations_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">longitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">obs_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates and saves new netcdf file at input lat / lon coordinates</span>

<span class="sd">        This method can be used to reduce the size of too large grid files.</span>
<span class="sd">        It reduces the lon / lat dimensionality corresponding to the locations</span>
<span class="sd">        of the input lat / lon coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyaerocom</span> <span class="kn">import</span> <span class="n">UngriddedData</span><span class="p">,</span> <span class="n">print_log</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing AtStations file. This may take a while&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_data</span><span class="p">,</span> <span class="n">UngriddedData</span><span class="p">):</span>
            <span class="n">longitudes</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">longitude</span>
            <span class="n">latitudes</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">latitude</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">longitudes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Longitude and latitude arrays need to have the &#39;</span>
                             <span class="s1">&#39;same length (since they are supposed to belong) &#39;</span>
                             <span class="s1">&#39;to station_coordinates&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_dir</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CACHEDIR</span>
        <span class="k">if</span> <span class="n">savename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">savename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aerocom_filename</span><span class="p">(</span><span class="n">at_stations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>

        <span class="n">lon_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lat_idx</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">latitudes</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">):</span>
            <span class="n">lon_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_index</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lon</span><span class="p">))</span>
            <span class="n">lat_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_index</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span>

        <span class="n">lon_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">lon_idx</span><span class="p">))</span>
        <span class="n">lat_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">lat_idx</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">DimensionOrderError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions_tseries</span><span class="p">()</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span> <span class="n">lat_idx</span><span class="p">][:,:,</span><span class="n">lon_idx</span><span class="p">]</span>
        <span class="c1"># make sure everything went well with the dimensions</span>
        <span class="n">subset</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">savename</span><span class="p">)</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Finished computing AtStations file.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span></div>

<div class="viewcode-block" id="GriddedData.to_xarray"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.to_xarray">[docs]</a>    <span class="k">def</span> <span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">xarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">DataArray</span><span class="o">.</span><span class="n">from_iris</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span></div>

    <span class="k">def</span> <span class="nf">_check_meta_netcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get rid of empty entries and convert bools to int in meta&quot;&quot;&quot;</span>
        <span class="n">meta_out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">meta_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">meta_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">meta_out</span>

    <span class="k">def</span> <span class="nf">_to_netcdf_aerocom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">years</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">years_avail</span><span class="p">()</span>
        <span class="n">outpaths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_years</span><span class="p">(</span><span class="n">years</span><span class="p">):</span>
            <span class="n">subset</span><span class="o">.</span><span class="n">_check_meta_netcdf</span><span class="p">()</span>
            <span class="n">savename</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">aerocom_savename</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">savename</span><span class="p">)</span>
            <span class="n">iris</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
            <span class="n">outpaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outpaths</span>

<div class="viewcode-block" id="GriddedData.to_netcdf"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.to_netcdf">[docs]</a>    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">savename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save as NetCDF file</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        out_dir : str</span>
<span class="sd">            output direcory (must exist)</span>
<span class="sd">        savename : str, optional</span>
<span class="sd">            name of file. If None, :func:`aerocom_savename` is used which is</span>
<span class="sd">            generated automatically and may be modified via `**kwargs`</span>
<span class="sd">        **kwargs</span>
<span class="sd">            keywords for name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of output files created</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">savename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#use AeroCom convention</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_netcdf_aerocom</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_meta_netcdf</span><span class="p">()</span>
        <span class="n">savename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aerocom_savename</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">savename</span><span class="p">)</span>
        <span class="n">iris</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">fp</span><span class="p">]</span></div>

<div class="viewcode-block" id="GriddedData.interpolate"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">collapse_scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate cube at certain discrete points</span>

<span class="sd">        Reimplementation of method :func:`iris.cube.Cube.interpolate`, for</span>
<span class="sd">        details `see here &lt;http://scitools.org.uk/iris/docs/v1.10.0/iris/iris/</span>
<span class="sd">        cube.html#iris.cube.Cube.interpolate&gt;`__</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The input coordinates may also be provided using the input arg</span>
<span class="sd">        `**coords` which provides a more intuitive option (e.g. input</span>
<span class="sd">        ``(sample_points=[(&quot;longitude&quot;, [10, 20]), (&quot;latitude&quot;, [1, 2])])``</span>
<span class="sd">        is the same as input ``(longitude=[10, 20], latitude=[1,2])``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            sequence of coordinate pairs over which to interpolate</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme, pyaerocom default is nearest. If input is</span>
<span class="sd">            string, it is converted into the corresponding iris Interpolator</span>
<span class="sd">            object, see :func:`str_to_iris` for valid strings</span>
<span class="sd">        collapse_scalar : bool</span>
<span class="sd">            Whether to collapse the dimension of scalar sample points in the</span>
<span class="sd">            resulting cube. Default is True.</span>
<span class="sd">        **coords</span>
<span class="sd">            additional keyword args that may be used to provide the interpolation</span>
<span class="sd">            coordinates in an easier way than using the ``Cube`` argument</span>
<span class="sd">            `sample_points`. May also be a combination of both.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing interpolated data</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">            &gt;&gt;&gt; from pyaerocom import GriddedData</span>
<span class="sd">            &gt;&gt;&gt; data = GriddedData()</span>
<span class="sd">            &gt;&gt;&gt; data._init_testdata_default()</span>
<span class="sd">            &gt;&gt;&gt; itp = data.interpolate([(&quot;longitude&quot;, (10)),</span>
<span class="sd">            ...                         (&quot;latitude&quot; , (35))])</span>
<span class="sd">            &gt;&gt;&gt; print(itp.shape)</span>
<span class="sd">            (365, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scheme</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sample_points</span><span class="p">:</span>
            <span class="n">sample_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sample_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Interpolating data of shape </span><span class="si">{}</span><span class="s1">. This may take a while.&#39;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">itp_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span>
                                             <span class="n">collapse_scalar</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s2">&quot;Interpolation failed since grid of interpolated &quot;</span>
                              <span class="s2">&quot;Cube is too large&quot;</span><span class="p">)</span>
        <span class="n">print_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Successfully interpolated cube&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">itp_cube</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.regrid"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.regrid">[docs]</a>    <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lat_res_deg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lon_res_deg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;areaweighted&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regrid this grid to grid resolution of other grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GriddedData or Cube, optional</span>
<span class="sd">            other data object to regrid to. If None, then input args</span>
<span class="sd">            `lat_res` and `lon_res` are used to regrid.</span>
<span class="sd">        lat_res_deg : float or int, optional</span>
<span class="sd">            latitude resolution in degrees (is only used if input arg `other`</span>
<span class="sd">            is None)</span>
<span class="sd">        lon_res_deg : float or int, optional</span>
<span class="sd">            longitude resolution in degrees (is only used if input arg `other`</span>
<span class="sd">            is None)</span>
<span class="sd">        scheme : str</span>
<span class="sd">            regridding scheme (e.g. linear, neirest, areaweighted)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            regridded data object (new instance, this object remains unchanged)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scheme</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">lat_res_deg</span><span class="p">,</span> <span class="n">lon_res_deg</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Missing input for regridding. Need either &#39;</span>
                                 <span class="s1">&#39;other data object or both lat_res_deg and &#39;</span>
                                 <span class="s1">&#39;lon_res_deg specified&#39;</span><span class="p">)</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">make_dummy_cube_latlon</span><span class="p">(</span><span class="n">lat_res_deg</span><span class="o">=</span><span class="n">lat_res_deg</span><span class="p">,</span>
                                           <span class="n">lon_res_deg</span><span class="o">=</span><span class="n">lon_res_deg</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_latlon_dims</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">has_latlon_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Can only regrid data objects with &#39;</span>
                                     <span class="s1">&#39;latitude and longitude dimensions&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_lonlat_bounds</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_check_lonlat_bounds</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_lon_circular</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">check_lon_circular</span><span class="p">()</span>

        <span class="n">data_rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">scheme</span><span class="p">)</span>
        <span class="n">suppl</span> <span class="o">=</span> <span class="n">od</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">suppl</span><span class="p">[</span><span class="s1">&#39;regridded&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">data_out</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data_rg</span><span class="p">,</span> <span class="o">**</span><span class="n">suppl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_out</span></div>

<div class="viewcode-block" id="GriddedData.check_lon_circular"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.check_lon_circular">[docs]</a>    <span class="k">def</span> <span class="nf">check_lon_circular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if latitude and longitude coordinates are circular&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_latlon_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;No lat lon dimensions available...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">circular</span> <span class="o">=</span> <span class="n">check_coord_circular</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>
                                                           <span class="mi">360</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">circular</span></div>

<div class="viewcode-block" id="GriddedData.collapsed"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.collapsed">[docs]</a>    <span class="k">def</span> <span class="nf">collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collapse cube</span>

<span class="sd">        Reimplementation of method :func:`iris.cube.Cube.collapsed`, for</span>
<span class="sd">        details `see here &lt;http://scitools.org.uk/iris/docs/latest/iris/iris/</span>
<span class="sd">        cube.html#iris.cube.Cube.collapsed&gt;`__</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : str or list</span>
<span class="sd">            string IDs of coordinate(s) that are to be collapsed (e.g.</span>
<span class="sd">            ``[&quot;longitude&quot;, &quot;latitude&quot;]``)</span>
<span class="sd">        aggregator : str or Aggregator or WeightedAggretor</span>
<span class="sd">            the aggregator used. If input is string, it is converted into the</span>
<span class="sd">            corresponding iris Aggregator object, see</span>
<span class="sd">            :func:`str_to_iris` for valid strings</span>
<span class="sd">        **kwargs</span>
<span class="sd">            additional keyword args (e.g. ``weights``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            collapsed data object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggregator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">aggregator</span> <span class="o">=</span> <span class="n">str_to_iris</span><span class="p">(</span><span class="n">aggregator</span><span class="p">)</span>
        <span class="n">collapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">collapsed</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.extract"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract subset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constraint : iris.Constraint</span>
<span class="sd">            constraint that is to be applied</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing cropped data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_crop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_crop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s2">&quot;Failed to extract subset&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cube</span> <span class="o">=</span> <span class="n">data_crop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data_crop</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.intersection"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ectract subset using :func:`iris.cube.Cube.intersection`</span>

<span class="sd">        See `here for details &lt;http://scitools.org.uk/iris/docs/v1.9.0/html/</span>
<span class="sd">        iris/iris/cube.html#iris.cube.Cube.intersection&gt;`__</span>
<span class="sd">        related to method and input parameters.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Only works if underlying grid data type is :class:`iris.cube.Cube`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args</span>
<span class="sd">            non-keyword args</span>
<span class="sd">        **kwargs</span>
<span class="sd">            keyword args</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            new data object containing cropped data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_crop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">data_crop</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

<div class="viewcode-block" id="GriddedData.quickplot_map"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.quickplot_map">[docs]</a>    <span class="k">def</span> <span class="nf">quickplot_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
                      <span class="n">add_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a quick plot onto a map</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_idx : int</span>
<span class="sd">            index in time to be plotted</span>
<span class="sd">        xlim : tuple</span>
<span class="sd">            2-element tuple specifying plotted longitude range</span>
<span class="sd">        ylim : tuple</span>
<span class="sd">            2-element tuple specifying plotted latitude range</span>
<span class="sd">        add_mean : bool</span>
<span class="sd">            if True, the mean value over the region and period is inserted</span>
<span class="sd">        **kwargs</span>
<span class="sd">            additional keyword arguments passed to</span>
<span class="sd">            :func:`pyaerocom.quickplot.plot_map`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig</span>
<span class="sd">            matplotlib figure instance containing plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Missing latitude dimension...&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Missing longitude dimension...&#39;</span><span class="p">)</span>
        <span class="n">tstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoord_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Invalid number of dimensions: </span><span class="si">{}</span><span class="s1">. &#39;</span>
                                         <span class="s1">&#39;Expected 3.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">to_pandas_timestamp</span><span class="p">(</span><span class="n">time_idx</span><span class="p">)</span><span class="o">.</span><span class="n">to_datetime64</span><span class="p">()</span>
                    <span class="n">time_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Failed to interpret input time stamp&#39;</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">cftime_to_datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">time_idx</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tstr</span> <span class="o">=</span> <span class="n">datetime2str</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tstr</span> <span class="o">=</span> <span class="n">datetime2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()[</span><span class="n">time_idx</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Failed to retrieve ts_type in &#39;</span>
                                      <span class="s1">&#39;GriddedData </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Invalid number of dimensions: </span><span class="si">{}</span><span class="s1">. &#39;</span>
                                         <span class="s1">&#39;Expected 2.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="kn">from</span> <span class="nn">pyaerocom.plot.mapping</span> <span class="kn">import</span> <span class="n">plot_griddeddata_on_map</span>

        <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_griddeddata_on_map</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">lons</span><span class="o">=</span><span class="n">lons</span><span class="p">,</span>
                                      <span class="n">lats</span><span class="o">=</span><span class="n">lats</span><span class="p">,</span>
                                      <span class="n">var_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span>
                                      <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                                      <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span>
                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_id</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">tstr</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">add_mean</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyaerocom.plot.config</span> <span class="kn">import</span> <span class="n">COLOR_THEME</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pyaerocom.mathutils</span> <span class="kn">import</span> <span class="n">exponent</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">vstr</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;{:.</span><span class="si">%s</span><span class="s1">f}&#39;</span><span class="o">%</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">mean</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
                <span class="n">mustr</span> <span class="o">=</span> <span class="s1">&#39;Mean=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vstr</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span><span class="o">==</span><span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="n">mustr</span> <span class="o">+=</span> <span class="s1">&#39; [</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="n">mustr</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">COLOR_THEME</span><span class="o">.</span><span class="n">color_map_text</span><span class="p">,</span>
                        <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
                        <span class="n">fontsize</span><span class="o">=</span><span class="mi">22</span><span class="p">,</span>
                        <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;#ffffff&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                                  <span class="n">alpha</span><span class="o">=</span><span class="mf">0.65</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Failed to compute / add area weighted mean. &#39;</span>
                                  <span class="s1">&#39;Reason: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="GriddedData.min"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Minimum value&quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.max"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum value&quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.area_weighted_mean"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.area_weighted_mean">[docs]</a>    <span class="k">def</span> <span class="nf">area_weighted_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get area weighted mean&quot;&quot;&quot;</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_weights</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">],</span>
                              <span class="n">aggregator</span><span class="o">=</span><span class="n">MEAN</span><span class="p">,</span>
                              <span class="n">weights</span><span class="o">=</span><span class="n">ws</span><span class="p">)</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span></div>

<div class="viewcode-block" id="GriddedData.mean"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">areaweighted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mean value of data array</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Corresponds to numerical mean of underlying N-dimensional numpy array.</span>
<span class="sd">        Does not consider area-weights or any other advanced averaging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="k">if</span> <span class="n">areaweighted</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_weighted_mean</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.std"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Standard deviation of values&quot;&quot;&quot;</span>
        <span class="c1">#make sure data is in memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span></div>

<div class="viewcode-block" id="GriddedData.short_str"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.short_str">[docs]</a>    <span class="k">def</span> <span class="nf">short_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Short string representation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;ID: </span><span class="si">{}</span><span class="s2">, Var: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_lonlat_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if longitude and latitude bounds are set and if not, guess&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">guess_bounds</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">guess_bounds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_testdata_default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method that loads ECMWF_OSUITE test data&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyaerocom.io.testfiles</span> <span class="kn">import</span> <span class="n">get</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_input</span><span class="p">(</span><span class="n">get</span><span class="p">()[</span><span class="s2">&quot;models&quot;</span><span class="p">][</span><span class="s2">&quot;ecmwf_osuite&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;od550aer&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size_GB</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size of original data files from which this object is created</span>

<span class="sd">        These method is intended to be used for operations that actually</span>
<span class="sd">        require the *realisation* of the (lazy loaded) data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">])</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_coordinate_access</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_standard_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_coord_info</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_standard_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;standard_name&#39;</span> <span class="p">:</span> <span class="n">val</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_var_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;var_name&#39;</span> <span class="p">:</span> <span class="n">val</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_long_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span> <span class="p">:</span> <span class="n">val</span><span class="p">}</span>
        <span class="k">raise</span> <span class="n">CoordinateError</span><span class="p">(</span><span class="s1">&#39;Could not associate one of the coordinates with &#39;</span>
                              <span class="s1">&#39;input string </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

<div class="viewcode-block" id="GriddedData.copy"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy this data object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="GriddedData.delete_aux_vars"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.delete_aux_vars">[docs]</a>    <span class="k">def</span> <span class="nf">delete_aux_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete auxiliary variables and iris AuxFactories&quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube</span>
        <span class="k">for</span> <span class="n">aux_fac</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>

            <span class="n">c</span><span class="o">.</span><span class="n">remove_aux_factory</span><span class="p">(</span><span class="n">aux_fac</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="p">):</span>
                <span class="n">c</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span></div>

<div class="viewcode-block" id="GriddedData.search_other"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.search_other">[docs]</a>    <span class="k">def</span> <span class="nf">search_other</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">require_same_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Searches data for another variable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">require_same_shape</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">concatenated</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Coming soon...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_files</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pyaerocom.io.iris_io</span> <span class="kn">import</span> <span class="n">load_cube_custom</span>
                <span class="n">cube</span> <span class="o">=</span> <span class="n">load_cube_custom</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                                        <span class="n">perform__fmt_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">from_files</span><span class="o">=</span><span class="n">file</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">vars_provided</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read_var</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span>
                                        <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                        <span class="n">stop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                                        <span class="n">ts_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_type</span><span class="p">,</span>
                                        <span class="n">flex_ts_type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">VariableNotFoundError</span><span class="p">(</span><span class="s1">&#39;Could not find variable </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_name</span><span class="p">))</span></div>

<div class="viewcode-block" id="GriddedData.update_meta"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.update_meta">[docs]</a>    <span class="k">def</span> <span class="nf">update_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update metadata dictionary&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;var_name&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Skipping assignment of var_name from &#39;</span>
                                     <span class="s1">&#39;metadata in GriddedData, since attr. &#39;</span>
                                     <span class="s1">&#39;needs to be str and is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>

<div class="viewcode-block" id="GriddedData.delete_all_coords"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.delete_all_coords">[docs]</a>    <span class="k">def</span> <span class="nf">delete_all_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes all coordinates (dimension + auxiliary) in this object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">delete_all_coords_cube</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">cube</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="GriddedData.copy_coords"><a class="viewcode-back" href="../../api.html#pyaerocom.griddeddata.GriddedData.copy_coords">[docs]</a>    <span class="k">def</span> <span class="nf">copy_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy all coordinates from other data object</span>

<span class="sd">        Requires the underlying data to be the same shape.</span>

<span class="sd">        Warning</span>
<span class="sd">        --------</span>
<span class="sd">        This operation will delete all existing coordinates and auxiliary</span>
<span class="sd">        coordinates and will then copy the ones from the input data object.</span>
<span class="sd">        No checks of any kind will be performed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GriddedData or Cube</span>
<span class="sd">            other data object (needs to be same shape as this object)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GriddedData</span>
<span class="sd">            data object containing coordinates from other object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataDimensionError</span><span class="p">(</span><span class="s1">&#39;Cannot copy coordinates: shape mismatch&#39;</span><span class="p">)</span>
        <span class="n">copy_coords_cube</span><span class="p">(</span><span class="n">to_cube</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">cube</span><span class="p">,</span> <span class="n">from_cube</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">cube</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">_update_coord_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">ln</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
            <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="n">vn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span>
            <span class="n">sn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">standard_name</span><span class="p">)</span>
            <span class="n">ln</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">long_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_names</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_var_names</span> <span class="o">=</span> <span class="n">vn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_standard_names</span> <span class="o">=</span> <span class="n">sn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord_long_names</span> <span class="o">=</span> <span class="n">ln</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices_or_attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x.__getitem__(y) &lt;==&gt; x[y]&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">indices_or_attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">indices_or_attr</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">which</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_coordinate_access</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="o">**</span><span class="n">which</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;GriddedData object has no &quot;</span>
                                     <span class="s2">&quot;attribute </span><span class="si">{}</span><span class="s2">&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">))</span>

        <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices_or_attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GriddedData</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if variable or coordinate matchs input string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span> <span class="o">+</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For now, use string representation of underlying data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;pyaerocom.GriddedData: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">Grid data: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For now, use representation of underlying data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;pyaerocom.GriddedData</span><span class="se">\n</span><span class="s2">Grid data: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Coming soon&#39;</span><span class="p">)</span>

    <span class="c1">#sorted out</span>
    <span class="k">def</span> <span class="nf">_to_timeseries_iter_coords_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span>
                                      <span class="n">collapse_scalar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract time-series for provided input coordinates (lon, lat)</span>

<span class="sd">        This method extracts the time-series at all input coordinates by</span>
<span class="sd">        iterating over the coordinate locations, cropping the grid around the</span>
<span class="sd">        coordinate and then interpolating it using</span>
<span class="sd">        the provided interpolation scheme.</span>

<span class="sd">        This method may be faster for a small number of coordinates (compared</span>
<span class="sd">        to :func:`to_timeseries`). It may also be the better choice in case the</span>
<span class="sd">        number of coordinates is too large in which case :func:`to_time_series`</span>
<span class="sd">        may fail due to a MemoryError (i.e. the case where the final</span>
<span class="sd">        interpolated object is too large to fit into memory).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points : list</span>
<span class="sd">            coordinates (e.g. lon / lat) at which time series is supposed to be</span>
<span class="sd">            retrieved</span>
<span class="sd">        scheme : str or iris interpolator object</span>
<span class="sd">            interpolation scheme (for details, see :func:`interpolate`)</span>
<span class="sd">        collapse_scalar : bool</span>
<span class="sd">            see :func:`interpolate`</span>
<span class="sd">        **coords</span>
<span class="sd">            additional keyword args that may be used to provide the interpolation</span>
<span class="sd">            coordinates (for details, see :func:`interpolate`)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of result dictionaries for each coordinate. Dictionary keys</span>
<span class="sd">            are: ``latitude, longitude, altitude, var_name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scheme</span><span class="o">==</span><span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_dimcoords_tseries</span><span class="p">()</span>

        <span class="n">lats</span><span class="p">,</span> <span class="n">lons</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sample_points</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;latitude&#39;</span><span class="p">:</span>
                <span class="n">lats</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;longitude&#39;</span><span class="p">:</span>
                <span class="n">lons</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_stamps</span><span class="p">()</span>
        <span class="n">grid_lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">grid_lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">points</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">totnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lats</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;At coord </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">totnum</span><span class="p">))</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">lat_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">grid_lats</span> <span class="o">-</span> <span class="n">lat</span><span class="p">))</span>
            <span class="n">lon_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">grid_lons</span> <span class="o">-</span> <span class="n">lon</span><span class="p">))</span>

            <span class="c1">#: TODO review indexing [:,:] style vs. extract method vs. lazy data</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">grid_lats</span><span class="p">[</span><span class="n">lat_idx</span><span class="p">],</span>
                               <span class="n">longitude</span><span class="o">=</span><span class="n">grid_lons</span><span class="p">[</span><span class="n">lon_idx</span><span class="p">])</span>

            <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

            <span class="n">vals</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data</span>
            <span class="c1">#sub = self.grid[:, lat_idx, lon_idx]</span>
            <span class="c1"># first slice, then access data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;latitude&#39;</span>   <span class="p">:</span>   <span class="n">lat</span><span class="p">,</span>
                           <span class="s1">&#39;longitude&#39;</span>  <span class="p">:</span>   <span class="n">lon</span><span class="p">,</span>
                           <span class="s1">&#39;name&#39;</span>       <span class="p">:</span>   <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">var</span>         <span class="p">:</span>   <span class="n">data</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1">### Deprecated (but still supported) stuff</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unit of data&quot;&quot;&quot;</span>
        <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;Attr. unit is deprecated, &#39;</span>
                                                <span class="s1">&#39;please use units instead&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">units</span>

    <span class="nd">@unit</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">const</span><span class="o">.</span><span class="n">print_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;Attr. unit is deprecated, &#39;</span>
                                                <span class="s1">&#39;please use units instead&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">val</span></div>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">pyaerocom</span> <span class="k">as</span> <span class="nn">pya</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

    <span class="c1"># print(&quot;uses last changes &quot;)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pya</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">ReadGridded</span><span class="p">(</span><span class="s1">&#39;ECMWF_CAMS_REAN&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read_var</span><span class="p">(</span><span class="s1">&#39;od550aer&#39;</span><span class="p">,</span>
                                                          <span class="n">start</span><span class="o">=</span><span class="mi">2010</span><span class="p">)</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span><span class="s1">&#39;yearly&#39;</span><span class="p">)</span>


    <span class="n">data1</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">()</span>
    <span class="n">data1</span><span class="o">.</span><span class="n">quickplot_map</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, MET Norway

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>